From 6757c0024687f914ac1c35343e56a05329351910 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gon=C3=A7alo=20Negrier=20Duarte?=
 <gonegrier.duarte@gmail.com>
Date: Thu, 7 Mar 2024 20:21:40 +0000
Subject: [PATCH] Rebase DXVK Reflex patch *
 https://github.com/doitsujin/dxvk/pull/3690
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Gon√ßalo Negrier Duarte <gonegrier.duarte@gmail.com>
---
 src/d3d11/d3d11_device.cpp         |  171 +++-
 src/d3d11/d3d11_device.h           |   78 +-
 src/d3d11/d3d11_initializer.cpp    |    2 +-
 src/d3d11/d3d11_interfaces.h       |   56 ++
 src/d3d11/d3d11_swapchain.cpp      |   51 +-
 src/d3d11/d3d11_swapchain.cpp.orig |  749 ++++++++++++++++
 src/d3d11/d3d11_swapchain.h        |   18 +-
 src/dxvk/dxvk_adapter.cpp          |   13 +-
 src/dxvk/dxvk_adapter.cpp.orig     | 1319 ++++++++++++++++++++++++++++
 src/dxvk/dxvk_adapter.cpp.rej      |   19 +
 src/dxvk/dxvk_cmdlist.cpp          |   17 +-
 src/dxvk/dxvk_cmdlist.h            |    5 +-
 src/dxvk/dxvk_context.cpp          |    4 +-
 src/dxvk/dxvk_context.h            |    3 +-
 src/dxvk/dxvk_device.cpp           |    6 +-
 src/dxvk/dxvk_device.h             |   55 +-
 src/dxvk/dxvk_device_info.h        |    3 +-
 src/dxvk/dxvk_device_info.h.orig   |   77 ++
 src/dxvk/dxvk_device_info.h.rej    |   13 +
 src/dxvk/dxvk_extensions.h         |    1 +
 src/dxvk/dxvk_extensions.h.orig    |  346 ++++++++
 src/dxvk/dxvk_extensions.h.rej     |   10 +
 src/dxvk/dxvk_presenter.cpp        |  132 ++-
 src/dxvk/dxvk_presenter.h          |   45 +
 src/dxvk/dxvk_queue.cpp            |    4 +-
 src/dxvk/dxvk_queue.h              |    1 +
 src/vulkan/vulkan_loader.h         |    8 +
 27 files changed, 3151 insertions(+), 55 deletions(-)
 create mode 100644 src/d3d11/d3d11_swapchain.cpp.orig
 create mode 100644 src/dxvk/dxvk_adapter.cpp.orig
 create mode 100644 src/dxvk/dxvk_adapter.cpp.rej
 create mode 100644 src/dxvk/dxvk_device_info.h.orig
 create mode 100644 src/dxvk/dxvk_device_info.h.rej
 create mode 100644 src/dxvk/dxvk_extensions.h.orig
 create mode 100644 src/dxvk/dxvk_extensions.h.rej

diff --git a/src/d3d11/d3d11_device.cpp b/src/d3d11/d3d11_device.cpp
index 2b9a82b9..ae4371c8 100644
--- a/src/d3d11/d3d11_device.cpp
+++ b/src/d3d11/d3d11_device.cpp
@@ -15,6 +15,7 @@
 #include "d3d11_device.h"
 #include "d3d11_fence.h"
 #include "d3d11_input_layout.h"
+#include "d3d11_interfaces.h"
 #include "d3d11_interop.h"
 #include "d3d11_query.h"
 #include "d3d11_resource.h"
@@ -2469,12 +2470,14 @@ namespace dxvk {
         return deviceFeatures.nvxBinaryImport
             && deviceFeatures.vk12.bufferDeviceAddress;
 
+      case D3D11_VK_NV_LOW_LATENCY_2:
+        return deviceFeatures.nvLowLatency2;
+
       default:
         return false;
     }
   }
-  
-  
+
   bool STDMETHODCALLTYPE D3D11DeviceExt::GetCudaTextureObjectNVX(uint32_t srvDriverHandle, uint32_t samplerDriverHandle, uint32_t* pCudaTextureHandle) {
     ID3D11ShaderResourceView* srv = HandleToSrvNVX(srvDriverHandle);
 
@@ -2783,8 +2786,132 @@ namespace dxvk {
 
 
 
-  
-  
+
+  D3D11LowLatencyDevice::D3D11LowLatencyDevice(
+          D3D11DXGIDevice*        pContainer,
+          D3D11Device*            pDevice)
+  : m_container(pContainer), m_device(pDevice) {
+    
+  }
+
+
+  ULONG STDMETHODCALLTYPE D3D11LowLatencyDevice::AddRef() {
+    return m_container->AddRef();
+  }
+
+
+  ULONG STDMETHODCALLTYPE D3D11LowLatencyDevice::Release() {
+    return m_container->Release();
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11LowLatencyDevice::QueryInterface(
+          REFIID                  riid,
+          void**                  ppvObject) {
+    return m_container->QueryInterface(riid, ppvObject);
+  }
+
+
+  BOOL STDMETHODCALLTYPE D3D11LowLatencyDevice::SupportsLowLatency() {
+    return m_device->GetDXVKDevice()->features().nvLowLatency2;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11LowLatencyDevice::LatencySleep() {
+    if (!m_device->GetDXVKDevice()->features().nvLowLatency2) {
+      return E_NOINTERFACE;
+    }
+
+    D3D11SwapChain* pSwapChain = m_device->GetLowLatencySwapChain();
+    if (pSwapChain && pSwapChain->LowLatencyEnabled()) {
+      pSwapChain->LatencySleep();
+    }
+
+    return S_OK;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11LowLatencyDevice::SetLatencySleepMode(BOOL lowLatencyMode, BOOL lowLatencyBoost, uint32_t minimumIntervalUs) {
+    if (!m_device->GetDXVKDevice()->features().nvLowLatency2) {
+      return E_NOINTERFACE;
+    }
+    
+    D3D11SwapChain* pSwapChain = m_device->GetLowLatencySwapChain();
+    if (pSwapChain) {
+      pSwapChain->SetLatencySleepMode(lowLatencyMode, lowLatencyBoost, minimumIntervalUs);
+    }
+
+    return S_OK;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11LowLatencyDevice::SetLatencyMarker(uint64_t frameID, uint32_t markerType) {
+    if (!m_device->GetDXVKDevice()->features().nvLowLatency2) {
+      return E_NOINTERFACE;
+    }
+
+    D3D11SwapChain* pSwapChain = m_device->GetLowLatencySwapChain();
+    VkLatencyMarkerNV marker = static_cast<VkLatencyMarkerNV>(markerType);
+    uint64_t internalFrameId = frameID + DXGI_MAX_SWAP_CHAIN_BUFFERS;
+
+    m_device->GetDXVKDevice()->setLatencyMarker(marker, internalFrameId);
+
+    if (pSwapChain && pSwapChain->LowLatencyEnabled()) {
+      pSwapChain->SetLatencyMarker(marker, internalFrameId);
+    }
+
+    return S_OK;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11LowLatencyDevice::GetLatencyInfo(D3D11_LATENCY_RESULTS* latencyResults)
+  {
+    if (!m_device->GetDXVKDevice()->features().nvLowLatency2) {
+      return E_NOINTERFACE;
+    }
+
+    constexpr uint32_t frameReportSize = 64; 
+    D3D11SwapChain* pSwapChain = m_device->GetLowLatencySwapChain();
+
+    if (pSwapChain && pSwapChain->LowLatencyEnabled()) {
+      std::vector<VkLatencyTimingsFrameReportNV> frameReports;
+      pSwapChain->GetLatencyTimings(frameReports);
+
+      if (frameReports.size() >= frameReportSize) {
+        for (uint32_t i = 0; i < frameReportSize; i++) {
+          VkLatencyTimingsFrameReportNV& frameReport = frameReports[i];
+          latencyResults->frame_reports[i].frameID = frameReport.presentID - DXGI_MAX_SWAP_CHAIN_BUFFERS;
+          latencyResults->frame_reports[i].inputSampleTime = frameReport.inputSampleTimeUs;
+          latencyResults->frame_reports[i].simStartTime = frameReport.simStartTimeUs;
+          latencyResults->frame_reports[i].simEndTime = frameReport.simEndTimeUs;
+          latencyResults->frame_reports[i].renderSubmitStartTime = frameReport.renderSubmitStartTimeUs;
+          latencyResults->frame_reports[i].renderSubmitEndTime = frameReport.renderSubmitEndTimeUs;
+          latencyResults->frame_reports[i].presentStartTime = frameReport.presentStartTimeUs;
+          latencyResults->frame_reports[i].presentEndTime = frameReport.presentEndTimeUs;
+          latencyResults->frame_reports[i].driverStartTime = frameReport.driverStartTimeUs;
+          latencyResults->frame_reports[i].driverEndTime = frameReport.driverEndTimeUs;
+          latencyResults->frame_reports[i].osRenderQueueStartTime = frameReport.osRenderQueueStartTimeUs;
+          latencyResults->frame_reports[i].osRenderQueueEndTime = frameReport.osRenderQueueEndTimeUs;
+          latencyResults->frame_reports[i].gpuRenderStartTime = frameReport.gpuRenderStartTimeUs;
+          latencyResults->frame_reports[i].gpuRenderEndTime = frameReport.gpuRenderEndTimeUs;
+          latencyResults->frame_reports[i].gpuActiveRenderTimeUs =
+            frameReport.gpuRenderEndTimeUs - frameReport.gpuRenderStartTimeUs;
+          latencyResults->frame_reports[i].gpuFrameTimeUs = 0;
+
+          if (i) {
+            latencyResults->frame_reports[i].gpuFrameTimeUs =
+              frameReports[i].gpuRenderEndTimeUs - frameReports[i - 1].gpuRenderEndTimeUs;
+          }
+        }
+      }
+    }
+
+    return S_OK;
+  }
+
+
+
+
   D3D11VideoDevice::D3D11VideoDevice(
           D3D11DXGIDevice*        pContainer,
           D3D11Device*            pDevice)
@@ -3021,7 +3148,11 @@ namespace dxvk {
 
       Com<D3D11SwapChain> presenter = new D3D11SwapChain(
         m_container, m_device, pSurfaceFactory, pDesc);
-      
+
+      if (m_device->GetDXVKDevice()->features().nvLowLatency2) {
+        m_device->AddSwapchain(presenter.ref());
+      }
+
       *ppSwapChain = presenter.ref();
       return S_OK;
     } catch (const DxvkError& e) {
@@ -3078,17 +3209,18 @@ namespace dxvk {
           Rc<DxvkDevice>      pDxvkDevice,
           D3D_FEATURE_LEVEL   FeatureLevel,
           UINT                FeatureFlags)
-  : m_dxgiAdapter   (pAdapter),
-    m_dxvkInstance  (pDxvkInstance),
-    m_dxvkAdapter   (pDxvkAdapter),
-    m_dxvkDevice    (pDxvkDevice),
-    m_d3d11Device   (this, FeatureLevel, FeatureFlags),
-    m_d3d11DeviceExt(this, &m_d3d11Device),
-    m_d3d11Interop  (this, &m_d3d11Device),
-    m_d3d11Video    (this, &m_d3d11Device),
-    m_d3d11on12     (this, &m_d3d11Device, pD3D12Device, pD3D12Queue),
-    m_metaDevice    (this),
-    m_dxvkFactory   (this, &m_d3d11Device) {
+  : m_dxgiAdapter         (pAdapter),
+    m_dxvkInstance        (pDxvkInstance),
+    m_dxvkAdapter         (pDxvkAdapter),
+    m_dxvkDevice          (pDxvkDevice),
+    m_d3d11Device         (this, FeatureLevel, FeatureFlags),
+    m_d3d11DeviceExt      (this, &m_d3d11Device),
+    m_d3d11Interop        (this, &m_d3d11Device),
+    m_d3dLowLatencyDevice (this, &m_d3d11Device),
+    m_d3d11Video          (this, &m_d3d11Device),
+    m_d3d11on12           (this, &m_d3d11Device, pD3D12Device, pD3D12Queue),
+    m_metaDevice          (this),
+    m_dxvkFactory         (this, &m_d3d11Device) {
 
   }
   
@@ -3142,7 +3274,12 @@ namespace dxvk {
       *ppvObject = ref(&m_d3d11DeviceExt);
       return S_OK;
     }
-    
+  
+    if (riid == __uuidof(ID3DLowLatencyDevice)) {
+      *ppvObject = ref(&m_d3dLowLatencyDevice);
+      return S_OK;
+    }
+
     if (riid == __uuidof(IDXGIDXVKDevice)) {
       *ppvObject = ref(&m_metaDevice);
       return S_OK;
diff --git a/src/d3d11/d3d11_device.h b/src/d3d11/d3d11_device.h
index 7a44b5ad..c04fcd75 100644
--- a/src/d3d11/d3d11_device.h
+++ b/src/d3d11/d3d11_device.h
@@ -24,6 +24,7 @@
 #include "d3d11_options.h"
 #include "d3d11_shader.h"
 #include "d3d11_state.h"
+#include "d3d11_swapchain.h"
 #include "d3d11_util.h"
 
 namespace dxvk {
@@ -428,6 +429,18 @@ namespace dxvk {
 
     bool Is11on12Device() const;
 
+    void AddSwapchain(D3D11SwapChain* swapchain) {
+      m_swapchains.push_back(swapchain);
+    }
+
+    void RemoveSwapchain(D3D11SwapChain* swapchain) {
+      m_swapchains.erase(std::remove(m_swapchains.begin(), m_swapchains.end(), swapchain));
+    }
+
+    D3D11SwapChain* GetLowLatencySwapChain() {
+      return (m_swapchains.size() == 1) ? m_swapchains[0] : nullptr;
+    }
+
     static D3D_FEATURE_LEVEL GetMaxFeatureLevel(
       const Rc<DxvkInstance>& Instance,
       const Rc<DxvkAdapter>&  Adapter);
@@ -464,6 +477,8 @@ namespace dxvk {
     D3D_FEATURE_LEVEL               m_maxFeatureLevel;
     D3D11DeviceFeatures             m_deviceFeatures;
 
+    std::vector<D3D11SwapChain*>    m_swapchains;
+
     HRESULT CreateShaderModule(
             D3D11CommonShader*      pShaderModule,
             DxvkShaderKey           ShaderKey,
@@ -545,28 +560,28 @@ namespace dxvk {
             uint64_t*               gpuVAStart,
             uint64_t*               gpuVASize);
 
-     bool STDMETHODCALLTYPE CreateUnorderedAccessViewAndGetDriverHandleNVX(
+    bool STDMETHODCALLTYPE CreateUnorderedAccessViewAndGetDriverHandleNVX(
             ID3D11Resource*                         pResource,
             const D3D11_UNORDERED_ACCESS_VIEW_DESC* pDesc,
             ID3D11UnorderedAccessView**             ppUAV,
             uint32_t*                               pDriverHandle);
 
-     bool STDMETHODCALLTYPE CreateShaderResourceViewAndGetDriverHandleNVX(
+    bool STDMETHODCALLTYPE CreateShaderResourceViewAndGetDriverHandleNVX(
             ID3D11Resource*                        pResource,
             const D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc,
             ID3D11ShaderResourceView**             ppSRV,
             uint32_t*                              pDriverHandle);
 
-     bool STDMETHODCALLTYPE CreateSamplerStateAndGetDriverHandleNVX(
+    bool STDMETHODCALLTYPE CreateSamplerStateAndGetDriverHandleNVX(
             const D3D11_SAMPLER_DESC* pSamplerDesc,
             ID3D11SamplerState**      ppSamplerState,
             uint32_t*                 pDriverHandle);
-    
+
   private:
     
     D3D11DXGIDevice* m_container;
     D3D11Device*     m_device;
-    
+
     void AddSamplerAndHandleNVX(
             ID3D11SamplerState*       pSampler,
             uint32_t                  Handle);
@@ -586,6 +601,46 @@ namespace dxvk {
     std::unordered_map<uint32_t, ID3D11ShaderResourceView*> m_srvHandleToPtr;
   };
 
+  /**
+   * \brief Extended D3D11 device
+   */
+  class D3D11LowLatencyDevice : public ID3DLowLatencyDevice {
+    
+  public:
+    
+    D3D11LowLatencyDevice(
+            D3D11DXGIDevice*        pContainer,
+            D3D11Device*            pDevice);
+    
+    ULONG STDMETHODCALLTYPE AddRef();
+    
+    ULONG STDMETHODCALLTYPE Release();
+    
+    HRESULT STDMETHODCALLTYPE QueryInterface(
+            REFIID                  riid,
+            void**                  ppvObject);
+
+    BOOL STDMETHODCALLTYPE SupportsLowLatency();
+
+    HRESULT STDMETHODCALLTYPE LatencySleep();
+
+    HRESULT STDMETHODCALLTYPE SetLatencySleepMode(
+            BOOL     lowLatencyMode,
+            BOOL     lowLatencyBoost,
+            uint32_t minimumIntervalUs);
+
+    HRESULT STDMETHODCALLTYPE SetLatencyMarker(
+            uint64_t frameID,
+            uint32_t markerType);
+
+    HRESULT STDMETHODCALLTYPE GetLatencyInfo(
+            D3D11_LATENCY_RESULTS* latencyResults);
+
+  private:
+    
+    D3D11DXGIDevice* m_container;
+    D3D11Device*     m_device;
+  };
 
   /**
    * \brief D3D11 video device
@@ -856,12 +911,13 @@ namespace dxvk {
     Rc<DxvkAdapter>     m_dxvkAdapter;
     Rc<DxvkDevice>      m_dxvkDevice;
 
-    D3D11Device         m_d3d11Device;
-    D3D11DeviceExt      m_d3d11DeviceExt;
-    D3D11VkInterop      m_d3d11Interop;
-    D3D11VideoDevice    m_d3d11Video;
-    D3D11on12Device     m_d3d11on12;
-    DXGIDXVKDevice      m_metaDevice;
+    D3D11Device           m_d3d11Device;
+    D3D11DeviceExt        m_d3d11DeviceExt;
+    D3D11VkInterop        m_d3d11Interop;
+    D3D11LowLatencyDevice m_d3dLowLatencyDevice;
+    D3D11VideoDevice      m_d3d11Video;
+    D3D11on12Device       m_d3d11on12;
+    DXGIDXVKDevice        m_metaDevice;
     
     DXGIVkSwapChainFactory   m_dxvkFactory;
     
diff --git a/src/d3d11/d3d11_initializer.cpp b/src/d3d11/d3d11_initializer.cpp
index 105485fa..9a97905f 100644
--- a/src/d3d11/d3d11_initializer.cpp
+++ b/src/d3d11/d3d11_initializer.cpp
@@ -280,7 +280,7 @@ namespace dxvk {
 
 
   void D3D11Initializer::FlushInternal() {
-    m_context->flushCommandList(nullptr);
+    m_context->flushCommandList(nullptr, false);
     
     m_transferCommands = 0;
     m_transferMemory   = 0;
diff --git a/src/d3d11/d3d11_interfaces.h b/src/d3d11/d3d11_interfaces.h
index 8a2e6fcf..f33eb6f3 100644
--- a/src/d3d11/d3d11_interfaces.h
+++ b/src/d3d11/d3d11_interfaces.h
@@ -16,6 +16,7 @@ enum D3D11_VK_EXTENSION : uint32_t {
   D3D11_VK_EXT_BARRIER_CONTROL            = 3,
   D3D11_VK_NVX_BINARY_IMPORT              = 4,
   D3D11_VK_NVX_IMAGE_VIEW_HANDLE          = 5,
+  D3D11_VK_NV_LOW_LATENCY_2               = 6
 };
 
 
@@ -27,6 +28,33 @@ enum D3D11_VK_BARRIER_CONTROL : uint32_t {
   D3D11_VK_BARRIER_CONTROL_IGNORE_GRAPHICS_UAV        = 1 << 1,
 };
 
+/**
+ * \brief Frame Report Info
+ */
+typedef struct D3D11_LATENCY_RESULTS
+{
+    UINT32 version;
+    struct D3D11_FRAME_REPORT {
+        UINT64 frameID;
+        UINT64 inputSampleTime;
+        UINT64 simStartTime;
+        UINT64 simEndTime;
+        UINT64 renderSubmitStartTime;
+        UINT64 renderSubmitEndTime;
+        UINT64 presentStartTime;
+        UINT64 presentEndTime;
+        UINT64 driverStartTime;
+        UINT64 driverEndTime;
+        UINT64 osRenderQueueStartTime;
+        UINT64 osRenderQueueEndTime;
+        UINT64 gpuRenderStartTime;
+        UINT64 gpuRenderEndTime;
+        UINT32 gpuActiveRenderTimeUs;
+        UINT32 gpuFrameTimeUs;
+        UINT8 rsvd[120];
+    } frame_reports[64];
+    UINT8 rsvd[32];
+} D3D11_LATENCY_RESULTS;
 
 /**
  * \brief Extended shader interface
@@ -114,6 +142,33 @@ ID3D11VkExtDevice1 : public ID3D11VkExtDevice {
           uint32_t*               pCudaTextureHandle) = 0;
 };
 
+/**
+ * \brief Extended extended D3D11 device
+ * 
+ * Introduces methods to get virtual addresses and driver
+ * handles for resources, and create and destroy objects
+ * for D3D11-Cuda interop.
+ */
+MIDL_INTERFACE("f3112584-41f9-348d-a59b-00b7e1d285d6")
+ID3DLowLatencyDevice : public IUnknown {
+    static const GUID guid;
+
+    virtual BOOL STDMETHODCALLTYPE SupportsLowLatency() = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE LatencySleep() = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE SetLatencySleepMode(
+        BOOL     lowLatencyMode,
+        BOOL     lowLatencyBoost,
+        uint32_t minimumIntervalUs) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE SetLatencyMarker(
+        uint64_t frameID,
+        uint32_t markerType) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetLatencyInfo(
+        D3D11_LATENCY_RESULTS* latencyResults) = 0;
+};
 
 /**
  * \brief Extended D3D11 context
@@ -189,4 +244,5 @@ __CRT_UUID_DECL(ID3D11VkExtDevice,         0x8a6e3c42,0xf74c,0x45b7,0x82,0x65,0x
 __CRT_UUID_DECL(ID3D11VkExtDevice1,        0xcfcf64ef,0x9586,0x46d0,0xbc,0xa4,0x97,0xcf,0x2c,0xa6,0x1b,0x06);
 __CRT_UUID_DECL(ID3D11VkExtContext,        0xfd0bca13,0x5cb6,0x4c3a,0x98,0x7e,0x47,0x50,0xde,0x2c,0xa7,0x91);
 __CRT_UUID_DECL(ID3D11VkExtContext1,       0x874b09b2,0xae0b,0x41d8,0x84,0x76,0x5f,0x3b,0x7a,0x0e,0x87,0x9d);
+__CRT_UUID_DECL(ID3DLowLatencyDevice,      0xf3112584,0x41f9,0x348d,0xa5,0x9b,0x00,0xb7,0xe1,0xd2,0x85,0xd6);
 #endif
diff --git a/src/d3d11/d3d11_swapchain.cpp b/src/d3d11/d3d11_swapchain.cpp
index 73939e2c..1154b941 100644
--- a/src/d3d11/d3d11_swapchain.cpp
+++ b/src/d3d11/d3d11_swapchain.cpp
@@ -84,7 +84,11 @@ namespace dxvk {
 
     m_device->waitForSubmission(&m_presentStatus);
     m_device->waitForIdle();
-    
+
+    if (m_device->features().nvLowLatency2) {
+      m_parent->RemoveSwapchain(this);
+    }
+
     DestroyFrameLatencyEvent();
   }
 
@@ -347,6 +351,43 @@ namespace dxvk {
   }
 
 
+  void D3D11SwapChain::SetLatencySleepMode(
+          bool lowLatencyMode,
+          bool lowLatencyBoost,
+          uint32_t minimumIntervalUs) {
+    m_presenter->setLatencySleepMode(lowLatencyMode, lowLatencyBoost, minimumIntervalUs);
+
+    // The swapchain will have its low latency state updated
+    // when it gets recreated. The swapchain needs to be recreated
+    // to ensure we can use the frameId provided by the application
+    // as a presentId as presentation time.
+    m_dirty = true;
+  }
+
+
+  void D3D11SwapChain::LatencySleep() {
+    m_presenter->latencySleep();
+  }
+
+
+  void D3D11SwapChain::SetLatencyMarker(
+          VkLatencyMarkerNV marker,
+          uint64_t presentId) {
+    m_presenter->setLatencyMarker(marker, presentId);
+  }
+
+
+  void D3D11SwapChain::GetLatencyTimings(
+          std::vector<VkLatencyTimingsFrameReportNV>& frameReports) {
+    m_presenter->getLatencyTimings(frameReports);
+  }
+
+
+  bool D3D11SwapChain::LowLatencyEnabled() {
+    return m_presenter->lowLatencyEnabled();
+  }
+
+
   HRESULT D3D11SwapChain::PresentImage(UINT SyncInterval) {
     // Flush pending rendering commands before
     auto immediateContext = m_parent->GetContext();
@@ -405,9 +446,11 @@ namespace dxvk {
           uint32_t                Repeat) {
     auto lock = pContext->LockContext();
 
-    // Bump frame ID as necessary
-    if (!Repeat)
-      m_frameId += 1;
+    if (!Repeat) {
+      m_frameId = (m_presenter->lowLatencyEnabled() && m_device->getLatencyMarkers().present) ?
+        m_device->getLatencyMarkers().present :
+        m_frameId + 1;
+    }
 
     // Present from CS thread so that we don't
     // have to synchronize with it first.
diff --git a/src/d3d11/d3d11_swapchain.cpp.orig b/src/d3d11/d3d11_swapchain.cpp.orig
new file mode 100644
index 00000000..73939e2c
--- /dev/null
+++ b/src/d3d11/d3d11_swapchain.cpp.orig
@@ -0,0 +1,749 @@
+#include "d3d11_context_imm.h"
+#include "d3d11_device.h"
+#include "d3d11_swapchain.h"
+
+#include "../util/util_win32_compat.h"
+
+namespace dxvk {
+
+  static uint16_t MapGammaControlPoint(float x) {
+    if (x < 0.0f) x = 0.0f;
+    if (x > 1.0f) x = 1.0f;
+    return uint16_t(65535.0f * x);
+  }
+
+  static VkColorSpaceKHR ConvertColorSpace(DXGI_COLOR_SPACE_TYPE colorspace) {
+    switch (colorspace) {
+      case DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709:    return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
+      case DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020: return VK_COLOR_SPACE_HDR10_ST2084_EXT;
+      case DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709:    return VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT;
+      default:
+        Logger::warn(str::format("DXGI: ConvertColorSpace: Unknown colorspace ", colorspace));
+        return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
+    }
+  }
+
+  static VkXYColorEXT ConvertXYColor(const UINT16 (&dxgiColor)[2]) {
+    return VkXYColorEXT{ float(dxgiColor[0]) / 50000.0f, float(dxgiColor[1]) / 50000.0f };
+  }
+
+  static float ConvertMaxLuminance(UINT dxgiLuminance) {
+    return float(dxgiLuminance);
+  }
+
+  static float ConvertMinLuminance(UINT dxgiLuminance) {
+    return float(dxgiLuminance) * 0.0001f;
+  }
+
+  static float ConvertLevel(UINT16 dxgiLevel) {
+    return float(dxgiLevel);
+  }
+
+  static VkHdrMetadataEXT ConvertHDRMetadata(const DXGI_HDR_METADATA_HDR10& dxgiMetadata) {
+    VkHdrMetadataEXT vkMetadata = { VK_STRUCTURE_TYPE_HDR_METADATA_EXT };
+    vkMetadata.displayPrimaryRed         = ConvertXYColor(dxgiMetadata.RedPrimary);
+    vkMetadata.displayPrimaryGreen       = ConvertXYColor(dxgiMetadata.GreenPrimary);
+    vkMetadata.displayPrimaryBlue        = ConvertXYColor(dxgiMetadata.BluePrimary);
+    vkMetadata.whitePoint                = ConvertXYColor(dxgiMetadata.WhitePoint);
+    vkMetadata.maxLuminance              = ConvertMaxLuminance(dxgiMetadata.MaxMasteringLuminance);
+    vkMetadata.minLuminance              = ConvertMinLuminance(dxgiMetadata.MinMasteringLuminance);
+    vkMetadata.maxContentLightLevel      = ConvertLevel(dxgiMetadata.MaxContentLightLevel);
+    vkMetadata.maxFrameAverageLightLevel = ConvertLevel(dxgiMetadata.MaxFrameAverageLightLevel);
+    return vkMetadata;
+  }
+
+
+  D3D11SwapChain::D3D11SwapChain(
+          D3D11DXGIDevice*        pContainer,
+          D3D11Device*            pDevice,
+          IDXGIVkSurfaceFactory*  pSurfaceFactory,
+    const DXGI_SWAP_CHAIN_DESC1*  pDesc)
+  : m_dxgiDevice(pContainer),
+    m_parent(pDevice),
+    m_surfaceFactory(pSurfaceFactory),
+    m_desc(*pDesc),
+    m_device(pDevice->GetDXVKDevice()),
+    m_context(m_device->createContext(DxvkContextType::Supplementary)),
+    m_frameLatencyCap(pDevice->GetOptions()->maxFrameLatency) {
+    CreateFrameLatencyEvent();
+    CreatePresenter();
+    CreateBackBuffer();
+    CreateBlitter();
+    CreateHud();
+
+    if (!pDevice->GetOptions()->deferSurfaceCreation)
+      RecreateSwapChain();
+  }
+
+
+  D3D11SwapChain::~D3D11SwapChain() {
+    // Avoids hanging when in this state, see comment
+    // in DxvkDevice::~DxvkDevice.
+    if (this_thread::isInModuleDetachment())
+      return;
+
+    m_device->waitForSubmission(&m_presentStatus);
+    m_device->waitForIdle();
+    
+    DestroyFrameLatencyEvent();
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::QueryInterface(
+          REFIID                  riid,
+          void**                  ppvObject) {
+    if (ppvObject == nullptr)
+      return E_POINTER;
+
+    InitReturnPtr(ppvObject);
+
+    if (riid == __uuidof(IUnknown)
+     || riid == __uuidof(IDXGIVkSwapChain)
+     || riid == __uuidof(IDXGIVkSwapChain1)) {
+      *ppvObject = ref(this);
+      return S_OK;
+    }
+
+    if (logQueryInterfaceError(__uuidof(IDXGIVkSwapChain), riid)) {
+      Logger::warn("D3D11SwapChain::QueryInterface: Unknown interface query");
+      Logger::warn(str::format(riid));
+    }
+
+    return E_NOINTERFACE;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::GetDesc(
+          DXGI_SWAP_CHAIN_DESC1*    pDesc) {
+    *pDesc = m_desc;
+    return S_OK;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::GetAdapter(
+          REFIID                    riid,
+          void**                    ppvObject) {
+    return m_dxgiDevice->GetParent(riid, ppvObject);
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::GetDevice(
+          REFIID                    riid,
+          void**                    ppDevice) {
+    return m_dxgiDevice->QueryInterface(riid, ppDevice);
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::GetImage(
+          UINT                      BufferId,
+          REFIID                    riid,
+          void**                    ppBuffer) {
+    InitReturnPtr(ppBuffer);
+
+    if (BufferId > 0) {
+      Logger::err("D3D11: GetImage: BufferId > 0 not supported");
+      return DXGI_ERROR_UNSUPPORTED;
+    }
+
+    return m_backBuffer->QueryInterface(riid, ppBuffer);
+  }
+
+
+  UINT STDMETHODCALLTYPE D3D11SwapChain::GetImageIndex() {
+    return 0;
+  }
+
+
+  UINT STDMETHODCALLTYPE D3D11SwapChain::GetFrameLatency() {
+    return m_frameLatency;
+  }
+
+
+  HANDLE STDMETHODCALLTYPE D3D11SwapChain::GetFrameLatencyEvent() {
+    HANDLE result = nullptr;
+    HANDLE processHandle = GetCurrentProcess();
+
+    if (!DuplicateHandle(processHandle, m_frameLatencyEvent,
+        processHandle, &result, 0, FALSE, DUPLICATE_SAME_ACCESS)) {
+      Logger::err("DxgiSwapChain::GetFrameLatencyWaitableObject: DuplicateHandle failed");
+      return nullptr;
+    }
+
+    return result;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::ChangeProperties(
+    const DXGI_SWAP_CHAIN_DESC1*    pDesc,
+    const UINT*                     pNodeMasks,
+          IUnknown* const*          ppPresentQueues) {
+    m_dirty |= m_desc.Format      != pDesc->Format
+            || m_desc.Width       != pDesc->Width
+            || m_desc.Height      != pDesc->Height
+            || m_desc.BufferCount != pDesc->BufferCount
+            || m_desc.Flags       != pDesc->Flags;
+
+    m_desc = *pDesc;
+    CreateBackBuffer();
+    return S_OK;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::SetPresentRegion(
+    const RECT*                     pRegion) {
+    // TODO implement
+    return E_NOTIMPL;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::SetGammaControl(
+          UINT                      NumControlPoints,
+    const DXGI_RGB*                 pControlPoints) {
+    bool isIdentity = true;
+
+    if (NumControlPoints > 1) {
+      std::array<DxvkGammaCp, 1025> cp;
+
+      if (NumControlPoints > cp.size())
+        return E_INVALIDARG;
+      
+      for (uint32_t i = 0; i < NumControlPoints; i++) {
+        uint16_t identity = MapGammaControlPoint(float(i) / float(NumControlPoints - 1));
+
+        cp[i].r = MapGammaControlPoint(pControlPoints[i].Red);
+        cp[i].g = MapGammaControlPoint(pControlPoints[i].Green);
+        cp[i].b = MapGammaControlPoint(pControlPoints[i].Blue);
+        cp[i].a = 0;
+
+        isIdentity &= cp[i].r == identity
+                   && cp[i].g == identity
+                   && cp[i].b == identity;
+      }
+
+      if (!isIdentity)
+        m_blitter->setGammaRamp(NumControlPoints, cp.data());
+    }
+
+    if (isIdentity)
+      m_blitter->setGammaRamp(0, nullptr);
+
+    return S_OK;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::SetFrameLatency(
+          UINT                      MaxLatency) {
+    if (MaxLatency == 0 || MaxLatency > DXGI_MAX_SWAP_CHAIN_BUFFERS)
+      return DXGI_ERROR_INVALID_CALL;
+
+    if (m_frameLatencyEvent) {
+      // Windows DXGI does not seem to handle the case where the new maximum
+      // latency is less than the current value, and some games relying on
+      // this behaviour will hang if we attempt to decrement the semaphore.
+      // Thus, only increment the semaphore as necessary.
+      if (MaxLatency > m_frameLatency)
+        ReleaseSemaphore(m_frameLatencyEvent, MaxLatency - m_frameLatency, nullptr);
+    }
+
+    m_frameLatency = MaxLatency;
+    return S_OK;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::Present(
+          UINT                      SyncInterval,
+          UINT                      PresentFlags,
+    const DXGI_PRESENT_PARAMETERS*  pPresentParameters) {
+    if (!(PresentFlags & DXGI_PRESENT_TEST))
+      m_dirty |= m_presenter->setSyncInterval(SyncInterval) != VK_SUCCESS;
+
+    HRESULT hr = S_OK;
+
+    if (!m_presenter->hasSwapChain()) {
+      RecreateSwapChain();
+      m_dirty = false;
+    }
+
+    if (!m_presenter->hasSwapChain())
+      hr = DXGI_STATUS_OCCLUDED;
+
+    if (m_device->getDeviceStatus() != VK_SUCCESS)
+      hr = DXGI_ERROR_DEVICE_RESET;
+
+    if (PresentFlags & DXGI_PRESENT_TEST)
+      return hr;
+
+    if (hr != S_OK) {
+      SyncFrameLatency();
+      return hr;
+    }
+
+    if (std::exchange(m_dirty, false))
+      RecreateSwapChain();
+
+    try {
+      hr = PresentImage(SyncInterval);
+    } catch (const DxvkError& e) {
+      Logger::err(e.message());
+      hr = E_FAIL;
+    }
+
+    // Ensure to synchronize and release the frame latency semaphore
+    // even if presentation failed with STATUS_OCCLUDED, or otherwise
+    // applications using the semaphore may deadlock. This works because
+    // we do not increment the frame ID in those situations.
+    SyncFrameLatency();
+    return hr;
+  }
+
+
+  UINT STDMETHODCALLTYPE D3D11SwapChain::CheckColorSpaceSupport(
+          DXGI_COLOR_SPACE_TYPE     ColorSpace) {
+    UINT supportFlags = 0;
+
+    const VkColorSpaceKHR vkColorSpace = ConvertColorSpace(ColorSpace);
+    if (m_presenter->supportsColorSpace(vkColorSpace))
+      supportFlags |= DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT;
+
+    return supportFlags;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::SetColorSpace(
+          DXGI_COLOR_SPACE_TYPE     ColorSpace) {
+    if (!(CheckColorSpaceSupport(ColorSpace) & DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT))
+      return E_INVALIDARG;
+
+    const VkColorSpaceKHR vkColorSpace = ConvertColorSpace(ColorSpace);
+    m_dirty |= vkColorSpace != m_colorspace;
+    m_colorspace = vkColorSpace;
+
+    return S_OK;
+  }
+
+
+  HRESULT STDMETHODCALLTYPE D3D11SwapChain::SetHDRMetaData(
+    const DXGI_VK_HDR_METADATA*     pMetaData) {
+    // For some reason this call always seems to succeed on Windows
+    if (pMetaData->Type == DXGI_HDR_METADATA_TYPE_HDR10) {
+      m_hdrMetadata = ConvertHDRMetadata(pMetaData->HDR10);
+      m_dirtyHdrMetadata = true;
+    }
+
+    return S_OK;
+  }
+
+
+  void STDMETHODCALLTYPE D3D11SwapChain::GetLastPresentCount(
+          UINT64*                   pLastPresentCount) {
+    *pLastPresentCount = UINT64(m_frameId - DXGI_MAX_SWAP_CHAIN_BUFFERS);
+  }
+
+
+  void STDMETHODCALLTYPE D3D11SwapChain::GetFrameStatistics(
+          DXGI_VK_FRAME_STATISTICS* pFrameStatistics) {
+    std::lock_guard<dxvk::mutex> lock(m_frameStatisticsLock);
+    *pFrameStatistics = m_frameStatistics;
+  }
+
+
+  HRESULT D3D11SwapChain::PresentImage(UINT SyncInterval) {
+    // Flush pending rendering commands before
+    auto immediateContext = m_parent->GetContext();
+    immediateContext->EndFrame();
+    immediateContext->Flush();
+
+    for (uint32_t i = 0; i < SyncInterval || i < 1; i++) {
+      SynchronizePresent();
+
+      if (!m_presenter->hasSwapChain())
+        return i ? S_OK : DXGI_STATUS_OCCLUDED;
+
+      // Presentation semaphores and WSI swap chain image
+      PresenterInfo info = m_presenter->info();
+      PresenterSync sync;
+
+      uint32_t imageIndex = 0;
+
+      VkResult status = m_presenter->acquireNextImage(sync, imageIndex);
+
+      while (status != VK_SUCCESS && status != VK_SUBOPTIMAL_KHR) {
+        RecreateSwapChain();
+
+        if (!m_presenter->hasSwapChain())
+          return i ? S_OK : DXGI_STATUS_OCCLUDED;
+        
+        info = m_presenter->info();
+        status = m_presenter->acquireNextImage(sync, imageIndex);
+      }
+
+      if (m_hdrMetadata && m_dirtyHdrMetadata) {
+        m_presenter->setHdrMetadata(*m_hdrMetadata);
+        m_dirtyHdrMetadata = false;
+      }
+
+      m_context->beginRecording(
+        m_device->createCommandList());
+      
+      m_blitter->presentImage(m_context.ptr(),
+        m_imageViews.at(imageIndex), VkRect2D(),
+        m_swapImageView, VkRect2D());
+
+      if (m_hud != nullptr)
+        m_hud->render(m_context, info.format, info.imageExtent);
+      
+      SubmitPresent(immediateContext, sync, i);
+    }
+
+    return S_OK;
+  }
+
+
+  void D3D11SwapChain::SubmitPresent(
+          D3D11ImmediateContext*  pContext,
+    const PresenterSync&          Sync,
+          uint32_t                Repeat) {
+    auto lock = pContext->LockContext();
+
+    // Bump frame ID as necessary
+    if (!Repeat)
+      m_frameId += 1;
+
+    // Present from CS thread so that we don't
+    // have to synchronize with it first.
+    m_presentStatus.result = VK_NOT_READY;
+
+    pContext->EmitCs([this,
+      cRepeat      = Repeat,
+      cSync        = Sync,
+      cHud         = m_hud,
+      cPresentMode = m_presenter->info().presentMode,
+      cFrameId     = m_frameId,
+      cCommandList = m_context->endRecording()
+    ] (DxvkContext* ctx) {
+      cCommandList->setWsiSemaphores(cSync);
+      m_device->submitCommandList(cCommandList, nullptr);
+
+      if (cHud != nullptr && !cRepeat)
+        cHud->update();
+
+      uint64_t frameId = cRepeat ? 0 : cFrameId;
+
+      m_device->presentImage(m_presenter,
+        cPresentMode, frameId, &m_presentStatus);
+    });
+
+    pContext->FlushCsChunk();
+  }
+
+
+  void D3D11SwapChain::SynchronizePresent() {
+    // Recreate swap chain if the previous present call failed
+    VkResult status = m_device->waitForSubmission(&m_presentStatus);
+    
+    if (status != VK_SUCCESS)
+      RecreateSwapChain();
+  }
+
+
+  void D3D11SwapChain::RecreateSwapChain() {
+    // Ensure that we can safely destroy the swap chain
+    m_device->waitForSubmission(&m_presentStatus);
+    m_device->waitForIdle();
+
+    m_presentStatus.result = VK_SUCCESS;
+    m_dirtyHdrMetadata = true;
+
+    PresenterDesc presenterDesc;
+    presenterDesc.imageExtent     = { m_desc.Width, m_desc.Height };
+    presenterDesc.imageCount      = PickImageCount(m_desc.BufferCount + 1);
+    presenterDesc.numFormats      = PickFormats(m_desc.Format, presenterDesc.formats);
+    presenterDesc.fullScreenExclusive = PickFullscreenMode();
+
+    VkResult vr = m_presenter->recreateSwapChain(presenterDesc);
+
+    if (vr == VK_ERROR_SURFACE_LOST_KHR) {
+      vr = m_presenter->recreateSurface([this] (VkSurfaceKHR* surface) {
+        return CreateSurface(surface);
+      });
+
+      if (vr)
+        throw DxvkError(str::format("D3D11SwapChain: Failed to recreate surface: ", vr));
+
+      vr = m_presenter->recreateSwapChain(presenterDesc);
+    }
+
+    if (vr)
+      throw DxvkError(str::format("D3D11SwapChain: Failed to recreate swap chain: ", vr));
+    
+    CreateRenderTargetViews();
+  }
+
+
+  void D3D11SwapChain::CreateFrameLatencyEvent() {
+    m_frameLatencySignal = new sync::CallbackFence(m_frameId);
+
+    if (m_desc.Flags & DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT)
+      m_frameLatencyEvent = CreateSemaphore(nullptr, m_frameLatency, DXGI_MAX_SWAP_CHAIN_BUFFERS, nullptr);
+  }
+
+
+  void D3D11SwapChain::CreatePresenter() {
+    PresenterDesc presenterDesc;
+    presenterDesc.imageExtent     = { m_desc.Width, m_desc.Height };
+    presenterDesc.imageCount      = PickImageCount(m_desc.BufferCount + 1);
+    presenterDesc.numFormats      = PickFormats(m_desc.Format, presenterDesc.formats);
+    presenterDesc.fullScreenExclusive = PickFullscreenMode();
+
+    m_presenter = new Presenter(m_device, m_frameLatencySignal, presenterDesc);
+    m_presenter->setFrameRateLimit(m_parent->GetOptions()->maxFrameRate);
+  }
+
+
+  VkResult D3D11SwapChain::CreateSurface(VkSurfaceKHR* pSurface) {
+    Rc<DxvkAdapter> adapter = m_device->adapter();
+
+    return m_surfaceFactory->CreateSurface(
+      adapter->vki()->instance(),
+      adapter->handle(), pSurface);
+  }
+
+
+  void D3D11SwapChain::CreateRenderTargetViews() {
+    PresenterInfo info = m_presenter->info();
+
+    m_imageViews.clear();
+    m_imageViews.resize(info.imageCount);
+
+    DxvkImageCreateInfo imageInfo;
+    imageInfo.type        = VK_IMAGE_TYPE_2D;
+    imageInfo.format      = info.format.format;
+    imageInfo.flags       = 0;
+    imageInfo.sampleCount = VK_SAMPLE_COUNT_1_BIT;
+    imageInfo.extent      = { info.imageExtent.width, info.imageExtent.height, 1 };
+    imageInfo.numLayers   = 1;
+    imageInfo.mipLevels   = 1;
+    imageInfo.usage       = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
+    imageInfo.stages      = 0;
+    imageInfo.access      = 0;
+    imageInfo.tiling      = VK_IMAGE_TILING_OPTIMAL;
+    imageInfo.layout      = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+    imageInfo.shared      = VK_TRUE;
+
+    DxvkImageViewCreateInfo viewInfo;
+    viewInfo.type         = VK_IMAGE_VIEW_TYPE_2D;
+    viewInfo.format       = info.format.format;
+    viewInfo.usage        = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
+    viewInfo.aspect       = VK_IMAGE_ASPECT_COLOR_BIT;
+    viewInfo.minLevel     = 0;
+    viewInfo.numLevels    = 1;
+    viewInfo.minLayer     = 0;
+    viewInfo.numLayers    = 1;
+
+    for (uint32_t i = 0; i < info.imageCount; i++) {
+      VkImage imageHandle = m_presenter->getImage(i).image;
+      
+      Rc<DxvkImage> image = new DxvkImage(
+        m_device.ptr(), imageInfo, imageHandle,
+        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
+
+      m_imageViews[i] = new DxvkImageView(
+        m_device->vkd(), image, viewInfo);
+    }
+  }
+
+
+  void D3D11SwapChain::CreateBackBuffer() {
+    // Explicitly destroy current swap image before
+    // creating a new one to free up resources
+    m_swapImage         = nullptr;
+    m_swapImageView     = nullptr;
+    m_backBuffer        = nullptr;
+
+    // Create new back buffer
+    D3D11_COMMON_TEXTURE_DESC desc;
+    desc.Width              = std::max(m_desc.Width,  1u);
+    desc.Height             = std::max(m_desc.Height, 1u);
+    desc.Depth              = 1;
+    desc.MipLevels          = 1;
+    desc.ArraySize          = 1;
+    desc.Format             = m_desc.Format;
+    desc.SampleDesc         = m_desc.SampleDesc;
+    desc.Usage              = D3D11_USAGE_DEFAULT;
+    desc.BindFlags          = 0;
+    desc.CPUAccessFlags     = 0;
+    desc.MiscFlags          = 0;
+    desc.TextureLayout      = D3D11_TEXTURE_LAYOUT_UNDEFINED;
+
+    if (m_desc.BufferUsage & DXGI_USAGE_RENDER_TARGET_OUTPUT)
+      desc.BindFlags |= D3D11_BIND_RENDER_TARGET;
+
+    if (m_desc.BufferUsage & DXGI_USAGE_SHADER_INPUT)
+      desc.BindFlags |= D3D11_BIND_SHADER_RESOURCE;
+
+    if (m_desc.BufferUsage & DXGI_USAGE_UNORDERED_ACCESS)
+      desc.BindFlags |= D3D11_BIND_UNORDERED_ACCESS;
+    
+    if (m_desc.Flags & DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE)
+      desc.MiscFlags |= D3D11_RESOURCE_MISC_GDI_COMPATIBLE;
+    
+    DXGI_USAGE dxgiUsage = DXGI_USAGE_BACK_BUFFER;
+
+    if (m_desc.SwapEffect == DXGI_SWAP_EFFECT_DISCARD
+     || m_desc.SwapEffect == DXGI_SWAP_EFFECT_FLIP_DISCARD)
+      dxgiUsage |= DXGI_USAGE_DISCARD_ON_PRESENT;
+
+    m_backBuffer = new D3D11Texture2D(m_parent, this, &desc, dxgiUsage);
+    m_swapImage = GetCommonTexture(m_backBuffer.ptr())->GetImage();
+
+    // Create an image view that allows the
+    // image to be bound as a shader resource.
+    DxvkImageViewCreateInfo viewInfo;
+    viewInfo.type       = VK_IMAGE_VIEW_TYPE_2D;
+    viewInfo.format     = m_swapImage->info().format;
+    viewInfo.usage      = VK_IMAGE_USAGE_SAMPLED_BIT;
+    viewInfo.aspect     = VK_IMAGE_ASPECT_COLOR_BIT;
+    viewInfo.minLevel   = 0;
+    viewInfo.numLevels  = 1;
+    viewInfo.minLayer   = 0;
+    viewInfo.numLayers  = 1;
+    m_swapImageView = m_device->createImageView(m_swapImage, viewInfo);
+    
+    // Initialize the image so that we can use it. Clearing
+    // to black prevents garbled output for the first frame.
+    VkImageSubresourceRange subresources;
+    subresources.aspectMask     = VK_IMAGE_ASPECT_COLOR_BIT;
+    subresources.baseMipLevel   = 0;
+    subresources.levelCount     = 1;
+    subresources.baseArrayLayer = 0;
+    subresources.layerCount     = 1;
+
+    m_context->beginRecording(
+      m_device->createCommandList());
+    
+    m_context->initImage(m_swapImage,
+      subresources, VK_IMAGE_LAYOUT_UNDEFINED);
+
+    m_device->submitCommandList(
+      m_context->endRecording(),
+      nullptr);
+  }
+
+
+  void D3D11SwapChain::CreateBlitter() {
+    m_blitter = new DxvkSwapchainBlitter(m_device);    
+  }
+
+
+  void D3D11SwapChain::CreateHud() {
+    m_hud = hud::Hud::createHud(m_device);
+
+    if (m_hud != nullptr)
+      m_hud->addItem<hud::HudClientApiItem>("api", 1, GetApiName());
+  }
+
+
+  void D3D11SwapChain::DestroyFrameLatencyEvent() {
+    CloseHandle(m_frameLatencyEvent);
+  }
+
+
+  void D3D11SwapChain::SyncFrameLatency() {
+    // Wait for the sync event so that we respect the maximum frame latency
+    m_frameLatencySignal->wait(m_frameId - GetActualFrameLatency());
+
+    m_frameLatencySignal->setCallback(m_frameId, [this,
+      cFrameId           = m_frameId,
+      cFrameLatencyEvent = m_frameLatencyEvent
+    ] () {
+      if (cFrameLatencyEvent)
+        ReleaseSemaphore(cFrameLatencyEvent, 1, nullptr);
+
+      std::lock_guard<dxvk::mutex> lock(m_frameStatisticsLock);
+      m_frameStatistics.PresentCount = cFrameId - DXGI_MAX_SWAP_CHAIN_BUFFERS;
+      m_frameStatistics.PresentQPCTime = dxvk::high_resolution_clock::get_counter();
+    });
+  }
+
+
+  uint32_t D3D11SwapChain::GetActualFrameLatency() {
+    // DXGI does not seem to implicitly synchronize waitable swap chains,
+    // so in that case we should just respect the user config. For regular
+    // swap chains, pick the latency from the DXGI device.
+    uint32_t maxFrameLatency = DXGI_MAX_SWAP_CHAIN_BUFFERS;
+
+    if (!(m_desc.Flags & DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT))
+      m_dxgiDevice->GetMaximumFrameLatency(&maxFrameLatency);
+
+    if (m_frameLatencyCap)
+      maxFrameLatency = std::min(maxFrameLatency, m_frameLatencyCap);
+
+    maxFrameLatency = std::min(maxFrameLatency, m_desc.BufferCount);
+    return maxFrameLatency;
+  }
+
+
+  uint32_t D3D11SwapChain::PickFormats(
+          DXGI_FORMAT               Format,
+          VkSurfaceFormatKHR*       pDstFormats) {
+    uint32_t n = 0;
+
+    switch (Format) {
+      default:
+        Logger::warn(str::format("D3D11SwapChain: Unexpected format: ", m_desc.Format));
+      [[fallthrough]];
+      
+      case DXGI_FORMAT_R8G8B8A8_UNORM:
+      case DXGI_FORMAT_B8G8R8A8_UNORM: {
+        pDstFormats[n++] = { VK_FORMAT_R8G8B8A8_UNORM, m_colorspace };
+        pDstFormats[n++] = { VK_FORMAT_B8G8R8A8_UNORM, m_colorspace };
+      } break;
+      
+      case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
+      case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB: {
+        pDstFormats[n++] = { VK_FORMAT_R8G8B8A8_SRGB, m_colorspace };
+        pDstFormats[n++] = { VK_FORMAT_B8G8R8A8_SRGB, m_colorspace };
+      } break;
+      
+      case DXGI_FORMAT_R10G10B10A2_UNORM: {
+        pDstFormats[n++] = { VK_FORMAT_A2B10G10R10_UNORM_PACK32, m_colorspace };
+        pDstFormats[n++] = { VK_FORMAT_A2R10G10B10_UNORM_PACK32, m_colorspace };
+      } break;
+      
+      case DXGI_FORMAT_R16G16B16A16_FLOAT: {
+        pDstFormats[n++] = { VK_FORMAT_R16G16B16A16_SFLOAT, m_colorspace };
+      } break;
+    }
+
+    return n;
+  }
+
+
+  uint32_t D3D11SwapChain::PickImageCount(
+          UINT                      Preferred) {
+    int32_t option = m_parent->GetOptions()->numBackBuffers;
+    return option > 0 ? uint32_t(option) : uint32_t(Preferred);
+  }
+
+
+  VkFullScreenExclusiveEXT D3D11SwapChain::PickFullscreenMode() {
+    return m_desc.Flags & DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH
+      ? VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT
+      : VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT;
+  }
+
+
+  std::string D3D11SwapChain::GetApiName() const {
+    Com<IDXGIDXVKDevice> device;
+    m_parent->QueryInterface(__uuidof(IDXGIDXVKDevice), reinterpret_cast<void**>(&device));
+
+    uint32_t apiVersion = device->GetAPIVersion();
+    uint32_t featureLevel = m_parent->GetFeatureLevel();
+
+    uint32_t flHi = (featureLevel >> 12);
+    uint32_t flLo = (featureLevel >> 8) & 0x7;
+
+    return str::format("D3D", apiVersion, " FL", flHi, "_", flLo);
+  }
+
+}
diff --git a/src/d3d11/d3d11_swapchain.h b/src/d3d11/d3d11_swapchain.h
index 00073d76..508f7aaf 100644
--- a/src/d3d11/d3d11_swapchain.h
+++ b/src/d3d11/d3d11_swapchain.h
@@ -86,6 +86,22 @@ namespace dxvk {
     void STDMETHODCALLTYPE GetFrameStatistics(
             DXGI_VK_FRAME_STATISTICS* pFrameStatistics);
 
+    void SetLatencySleepMode(
+            bool lowLatencyMode,
+            bool lowLatencyBoost,
+            uint32_t minimumIntervalUs);
+
+    void LatencySleep();
+
+    void SetLatencyMarker(
+            VkLatencyMarkerNV marker,
+            uint64_t presentId);
+
+    void GetLatencyTimings(
+            std::vector<VkLatencyTimingsFrameReportNV>& frameReports);
+
+    bool LowLatencyEnabled();
+
   private:
 
     enum BindingIds : uint32_t {
@@ -176,4 +192,4 @@ namespace dxvk {
 
   };
 
-}
\ No newline at end of file
+}
diff --git a/src/dxvk/dxvk_adapter.cpp b/src/dxvk/dxvk_adapter.cpp
index 7c0e79f5..949beda9 100644
--- a/src/dxvk/dxvk_adapter.cpp
+++ b/src/dxvk/dxvk_adapter.cpp
@@ -940,6 +940,9 @@ namespace dxvk {
       m_deviceFeatures.nvRawAccessChains.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.nvRawAccessChains);
     }
 
+    if (m_deviceExtensions.supports(VK_NV_LOW_LATENCY_2_EXTENSION_NAME))
+      m_deviceFeatures.nvLowLatency2 = VK_TRUE;
+
     if (m_deviceExtensions.supports(VK_NVX_BINARY_IMPORT_EXTENSION_NAME))
       m_deviceFeatures.nvxBinaryImport = VK_TRUE;
 
@@ -1007,6 +1010,7 @@ namespace dxvk {
       &devExtensions.khrPresentWait,
       &devExtensions.khrSwapchain,
       &devExtensions.khrWin32KeyedMutex,
+      &devExtensions.nvLowLatency2,
       &devExtensions.nvRawAccessChains,
       &devExtensions.nvxBinaryImport,
       &devExtensions.nvxImageViewHandle,
@@ -1152,8 +1156,13 @@ namespace dxvk {
       enabledFeatures.nvRawAccessChains.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.nvRawAccessChains);
     }
 
-    if (devExtensions.nvxBinaryImport)
+    if (devExtensions.nvxBinaryImport) {
       enabledFeatures.nvxBinaryImport = VK_TRUE;
+    }
+
+    if (devExtensions.nvLowLatency2) {
+      enabledFeatures.nvLowLatency2 = VK_TRUE;
+    }
 
     if (devExtensions.nvxImageViewHandle)
       enabledFeatures.nvxImageViewHandle = VK_TRUE;
@@ -1298,6 +1307,8 @@ namespace dxvk {
       "\n  presentId                              : ", features.khrPresentId.presentId ? "1" : "0",
       "\n", VK_KHR_PRESENT_WAIT_EXTENSION_NAME,
       "\n  presentWait                            : ", features.khrPresentWait.presentWait ? "1" : "0",
+      "\n", VK_NV_LOW_LATENCY_2_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.nvLowLatency2 ? "1" : "0",
       "\n", VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME,
       "\n  shaderRawAccessChains                  : ", features.nvRawAccessChains.shaderRawAccessChains ? "1" : "0",
       "\n", VK_NVX_BINARY_IMPORT_EXTENSION_NAME,
diff --git a/src/dxvk/dxvk_adapter.cpp.orig b/src/dxvk/dxvk_adapter.cpp.orig
new file mode 100644
index 00000000..7c0e79f5
--- /dev/null
+++ b/src/dxvk/dxvk_adapter.cpp.orig
@@ -0,0 +1,1319 @@
+#include <cstring>
+#include <unordered_set>
+
+#include "dxvk_adapter.h"
+#include "dxvk_device.h"
+#include "dxvk_instance.h"
+
+namespace dxvk {
+
+  DxvkDeviceQueue getDeviceQueue(const Rc<vk::DeviceFn>& vkd, uint32_t family, uint32_t index) {
+    DxvkDeviceQueue result = { };
+    result.queueFamily = family;
+    result.queueIndex = index;
+
+    if (family != VK_QUEUE_FAMILY_IGNORED)
+      vkd->vkGetDeviceQueue(vkd->device(), family, index, &result.queueHandle);
+
+    return result;
+  }
+
+
+  DxvkAdapter::DxvkAdapter(
+    const Rc<vk::InstanceFn>& vki,
+          VkPhysicalDevice    handle)
+  : m_vki           (vki),
+    m_handle        (handle) {
+    this->queryExtensions();
+    this->queryDeviceInfo();
+    this->queryDeviceFeatures();
+    this->queryDeviceQueues();
+
+    m_hasMemoryBudget = m_deviceExtensions.supports(VK_EXT_MEMORY_BUDGET_EXTENSION_NAME);
+  }
+  
+  
+  DxvkAdapter::~DxvkAdapter() {
+    
+  }
+  
+  
+  DxvkAdapterMemoryInfo DxvkAdapter::getMemoryHeapInfo() const {
+    VkPhysicalDeviceMemoryBudgetPropertiesEXT memBudget = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT };
+    VkPhysicalDeviceMemoryProperties2 memProps = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 };
+    memProps.pNext = m_hasMemoryBudget ? &memBudget : nullptr;
+
+    m_vki->vkGetPhysicalDeviceMemoryProperties2(m_handle, &memProps);
+    
+    DxvkAdapterMemoryInfo info = { };
+    info.heapCount = memProps.memoryProperties.memoryHeapCount;
+
+    for (uint32_t i = 0; i < info.heapCount; i++) {
+      info.heaps[i].heapFlags = memProps.memoryProperties.memoryHeaps[i].flags;
+      info.heaps[i].heapSize = memProps.memoryProperties.memoryHeaps[i].size;
+
+      if (m_hasMemoryBudget) {
+        // Handle DXVK's memory allocations separately so that
+        // freeing  resources actually is visible to applications.
+        VkDeviceSize allocated = m_memoryAllocated[i].load();
+        VkDeviceSize used = m_memoryUsed[i].load();
+
+        info.heaps[i].memoryBudget    = memBudget.heapBudget[i];
+        info.heaps[i].memoryAllocated = std::max(memBudget.heapUsage[i], allocated) - allocated + used;
+      } else {
+        info.heaps[i].memoryBudget    = memProps.memoryProperties.memoryHeaps[i].size;
+        info.heaps[i].memoryAllocated = m_memoryUsed[i].load();
+      }
+    }
+
+    return info;
+  }
+
+
+  VkPhysicalDeviceMemoryProperties DxvkAdapter::memoryProperties() const {
+    VkPhysicalDeviceMemoryProperties memoryProperties;
+    m_vki->vkGetPhysicalDeviceMemoryProperties(m_handle, &memoryProperties);
+    return memoryProperties;
+  }
+  
+  
+  DxvkFormatFeatures DxvkAdapter::getFormatFeatures(VkFormat format) const {
+    VkFormatProperties3 properties3 = { VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 };
+    VkFormatProperties2 properties2 = { VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2, &properties3 };
+    m_vki->vkGetPhysicalDeviceFormatProperties2(m_handle, format, &properties2);
+
+    DxvkFormatFeatures result;
+    result.optimal = properties3.optimalTilingFeatures;
+    result.linear  = properties3.linearTilingFeatures;
+    result.buffer  = properties3.bufferFeatures;
+    return result;
+  }
+
+
+  std::optional<DxvkFormatLimits> DxvkAdapter::getFormatLimits(
+    const DxvkFormatQuery&          query) const {
+    VkPhysicalDeviceExternalImageFormatInfo externalInfo = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO };
+    externalInfo.handleType = query.handleType;
+
+    VkPhysicalDeviceImageFormatInfo2 info = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 };
+    info.format = query.format;
+    info.type   = query.type;
+    info.tiling = query.tiling;
+    info.usage  = query.usage;
+    info.flags  = query.flags;
+
+    if (externalInfo.handleType)
+      externalInfo.pNext = std::exchange(info.pNext, &externalInfo);
+
+    VkExternalImageFormatProperties externalProperties = { VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES };
+    VkImageFormatProperties2 properties = { VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 };
+
+    if (externalInfo.handleType)
+      externalProperties.pNext = std::exchange(properties.pNext, &externalProperties);
+
+    VkResult vr = m_vki->vkGetPhysicalDeviceImageFormatProperties2(
+      m_handle, &info, &properties);
+
+    if (vr != VK_SUCCESS)
+      return std::nullopt;
+
+    DxvkFormatLimits result = { };
+    result.maxExtent        = properties.imageFormatProperties.maxExtent;
+    result.maxMipLevels     = properties.imageFormatProperties.maxMipLevels;
+    result.maxArrayLayers   = properties.imageFormatProperties.maxArrayLayers;
+    result.sampleCounts     = properties.imageFormatProperties.sampleCounts;
+    result.maxResourceSize  = properties.imageFormatProperties.maxResourceSize;
+    result.externalFeatures = externalProperties.externalMemoryProperties.externalMemoryFeatures;
+    return result;
+  }
+
+
+  DxvkAdapterQueueIndices DxvkAdapter::findQueueFamilies() const {
+    uint32_t graphicsQueue = findQueueFamily(
+      VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT,
+      VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT);
+    
+    uint32_t computeQueue = findQueueFamily(
+      VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT,
+      VK_QUEUE_COMPUTE_BIT);
+    
+    if (computeQueue == VK_QUEUE_FAMILY_IGNORED)
+      computeQueue = graphicsQueue;
+
+    uint32_t transferQueue = findQueueFamily(
+      VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT | VK_QUEUE_TRANSFER_BIT,
+      VK_QUEUE_TRANSFER_BIT);
+    
+    if (transferQueue == VK_QUEUE_FAMILY_IGNORED)
+      transferQueue = computeQueue;
+
+    uint32_t sparseQueue = VK_QUEUE_FAMILY_IGNORED;
+
+    if (m_queueFamilies[graphicsQueue].queueFlags & VK_QUEUE_SPARSE_BINDING_BIT) {
+      // Prefer using the graphics queue as a sparse binding queue
+      sparseQueue = graphicsQueue;
+    } else {
+      sparseQueue = findQueueFamily(
+        VK_QUEUE_SPARSE_BINDING_BIT,
+        VK_QUEUE_SPARSE_BINDING_BIT);
+    }
+
+    DxvkAdapterQueueIndices queues;
+    queues.graphics = graphicsQueue;
+    queues.transfer = transferQueue;
+    queues.sparse = sparseQueue;
+    return queues;
+  }
+
+#define CHECK_FEATURE_NEED(feature) \
+  (m_deviceFeatures.feature         \
+       || !required.feature)
+
+  bool DxvkAdapter::checkFeatureSupport(const DxvkDeviceFeatures& required) const {
+    return CHECK_FEATURE_NEED(core.features.robustBufferAccess)
+        && CHECK_FEATURE_NEED(core.features.fullDrawIndexUint32)
+        && CHECK_FEATURE_NEED(core.features.imageCubeArray)
+        && CHECK_FEATURE_NEED(core.features.independentBlend)
+        && CHECK_FEATURE_NEED(core.features.geometryShader)
+        && CHECK_FEATURE_NEED(core.features.tessellationShader)
+        && CHECK_FEATURE_NEED(core.features.sampleRateShading)
+        && CHECK_FEATURE_NEED(core.features.dualSrcBlend)
+        && CHECK_FEATURE_NEED(core.features.logicOp)
+        && CHECK_FEATURE_NEED(core.features.multiDrawIndirect)
+        && CHECK_FEATURE_NEED(core.features.drawIndirectFirstInstance)
+        && CHECK_FEATURE_NEED(core.features.depthClamp)
+        && CHECK_FEATURE_NEED(core.features.depthBiasClamp)
+        && CHECK_FEATURE_NEED(core.features.fillModeNonSolid)
+        && CHECK_FEATURE_NEED(core.features.depthBounds)
+        && CHECK_FEATURE_NEED(core.features.wideLines)
+        && CHECK_FEATURE_NEED(core.features.largePoints)
+        && CHECK_FEATURE_NEED(core.features.alphaToOne)
+        && CHECK_FEATURE_NEED(core.features.multiViewport)
+        && CHECK_FEATURE_NEED(core.features.samplerAnisotropy)
+        && CHECK_FEATURE_NEED(core.features.textureCompressionETC2)
+        && CHECK_FEATURE_NEED(core.features.textureCompressionASTC_LDR)
+        && CHECK_FEATURE_NEED(core.features.textureCompressionBC)
+        && CHECK_FEATURE_NEED(core.features.occlusionQueryPrecise)
+        && CHECK_FEATURE_NEED(core.features.pipelineStatisticsQuery)
+        && CHECK_FEATURE_NEED(core.features.vertexPipelineStoresAndAtomics)
+        && CHECK_FEATURE_NEED(core.features.fragmentStoresAndAtomics)
+        && CHECK_FEATURE_NEED(core.features.shaderTessellationAndGeometryPointSize)
+        && CHECK_FEATURE_NEED(core.features.shaderImageGatherExtended)
+        && CHECK_FEATURE_NEED(core.features.shaderStorageImageExtendedFormats)
+        && CHECK_FEATURE_NEED(core.features.shaderStorageImageMultisample)
+        && CHECK_FEATURE_NEED(core.features.shaderStorageImageReadWithoutFormat)
+        && CHECK_FEATURE_NEED(core.features.shaderStorageImageWriteWithoutFormat)
+        && CHECK_FEATURE_NEED(core.features.shaderUniformBufferArrayDynamicIndexing)
+        && CHECK_FEATURE_NEED(core.features.shaderSampledImageArrayDynamicIndexing)
+        && CHECK_FEATURE_NEED(core.features.shaderStorageBufferArrayDynamicIndexing)
+        && CHECK_FEATURE_NEED(core.features.shaderStorageImageArrayDynamicIndexing)
+        && CHECK_FEATURE_NEED(core.features.shaderClipDistance)
+        && CHECK_FEATURE_NEED(core.features.shaderCullDistance)
+        && CHECK_FEATURE_NEED(core.features.shaderFloat64)
+        && CHECK_FEATURE_NEED(core.features.shaderInt64)
+        && CHECK_FEATURE_NEED(core.features.shaderInt16)
+        && CHECK_FEATURE_NEED(core.features.shaderResourceResidency)
+        && CHECK_FEATURE_NEED(core.features.shaderResourceMinLod)
+        && CHECK_FEATURE_NEED(core.features.sparseBinding)
+        && CHECK_FEATURE_NEED(core.features.sparseResidencyBuffer)
+        && CHECK_FEATURE_NEED(core.features.sparseResidencyImage2D)
+        && CHECK_FEATURE_NEED(core.features.sparseResidencyImage3D)
+        && CHECK_FEATURE_NEED(core.features.sparseResidency2Samples)
+        && CHECK_FEATURE_NEED(core.features.sparseResidency4Samples)
+        && CHECK_FEATURE_NEED(core.features.sparseResidency8Samples)
+        && CHECK_FEATURE_NEED(core.features.sparseResidency16Samples)
+        && CHECK_FEATURE_NEED(core.features.sparseResidencyAliased)
+        && CHECK_FEATURE_NEED(core.features.variableMultisampleRate)
+        && CHECK_FEATURE_NEED(core.features.inheritedQueries)
+        && CHECK_FEATURE_NEED(vk11.shaderDrawParameters)
+        && CHECK_FEATURE_NEED(vk12.samplerMirrorClampToEdge)
+        && CHECK_FEATURE_NEED(vk12.drawIndirectCount)
+        && CHECK_FEATURE_NEED(vk12.hostQueryReset)
+        && CHECK_FEATURE_NEED(vk12.timelineSemaphore)
+        && CHECK_FEATURE_NEED(vk12.bufferDeviceAddress)
+        && CHECK_FEATURE_NEED(vk12.shaderOutputViewportIndex)
+        && CHECK_FEATURE_NEED(vk12.shaderOutputLayer)
+        && CHECK_FEATURE_NEED(vk13.pipelineCreationCacheControl)
+        && CHECK_FEATURE_NEED(vk13.shaderDemoteToHelperInvocation)
+        && CHECK_FEATURE_NEED(vk13.shaderZeroInitializeWorkgroupMemory)
+        && CHECK_FEATURE_NEED(vk13.synchronization2)
+        && CHECK_FEATURE_NEED(vk13.dynamicRendering)
+        && CHECK_FEATURE_NEED(vk13.maintenance4)
+        && CHECK_FEATURE_NEED(extAttachmentFeedbackLoopLayout.attachmentFeedbackLoopLayout)
+        && CHECK_FEATURE_NEED(extConservativeRasterization)
+        && CHECK_FEATURE_NEED(extCustomBorderColor.customBorderColors)
+        && CHECK_FEATURE_NEED(extCustomBorderColor.customBorderColorWithoutFormat)
+        && CHECK_FEATURE_NEED(extDepthClipEnable.depthClipEnable)
+        && CHECK_FEATURE_NEED(extDepthBiasControl.depthBiasControl)
+        && CHECK_FEATURE_NEED(extDepthBiasControl.leastRepresentableValueForceUnormRepresentation)
+        && CHECK_FEATURE_NEED(extDepthBiasControl.floatRepresentation)
+        && CHECK_FEATURE_NEED(extDepthBiasControl.depthBiasExact)
+        && CHECK_FEATURE_NEED(extGraphicsPipelineLibrary.graphicsPipelineLibrary)
+        && CHECK_FEATURE_NEED(extMemoryBudget)
+        && CHECK_FEATURE_NEED(extMemoryPriority.memoryPriority)
+        && CHECK_FEATURE_NEED(extNonSeamlessCubeMap.nonSeamlessCubeMap)
+        && CHECK_FEATURE_NEED(extRobustness2.robustBufferAccess2)
+        && CHECK_FEATURE_NEED(extRobustness2.robustImageAccess2)
+        && CHECK_FEATURE_NEED(extRobustness2.nullDescriptor)
+        && CHECK_FEATURE_NEED(extShaderModuleIdentifier.shaderModuleIdentifier)
+        && CHECK_FEATURE_NEED(extShaderStencilExport)
+        && CHECK_FEATURE_NEED(extSwapchainColorSpace)
+        && CHECK_FEATURE_NEED(extSwapchainMaintenance1.swapchainMaintenance1)
+        && CHECK_FEATURE_NEED(extHdrMetadata)
+        && CHECK_FEATURE_NEED(extTransformFeedback.transformFeedback)
+        && CHECK_FEATURE_NEED(extVertexAttributeDivisor.vertexAttributeInstanceRateDivisor)
+        && CHECK_FEATURE_NEED(extVertexAttributeDivisor.vertexAttributeInstanceRateZeroDivisor);
+  }
+
+#undef CHECK_FEATURE_NEED
+
+  void DxvkAdapter::enableExtensions(const DxvkNameSet& extensions) {
+    m_extraExtensions.merge(extensions);
+  }
+
+
+  Rc<DxvkDevice> DxvkAdapter::createDevice(
+    const Rc<DxvkInstance>&   instance,
+          DxvkDeviceFeatures  enabledFeatures) {
+    DxvkDeviceExtensions devExtensions;
+    auto devExtensionList = getExtensionList(devExtensions);
+
+    // Only enable Cuda interop extensions in 64-bit builds in
+    // order to avoid potential driver or address space issues.
+    // VK_KHR_buffer_device_address is expensive on some drivers.
+    bool enableCudaInterop = !env::is32BitHostPlatform() &&
+      m_deviceExtensions.supports(devExtensions.nvxBinaryImport.name()) &&
+      m_deviceExtensions.supports(devExtensions.nvxImageViewHandle.name()) &&
+      m_deviceFeatures.vk12.bufferDeviceAddress;
+
+    if (enableCudaInterop) {
+      devExtensions.nvxBinaryImport.setMode(DxvkExtMode::Optional);
+      devExtensions.nvxImageViewHandle.setMode(DxvkExtMode::Optional);
+
+      enabledFeatures.vk12.bufferDeviceAddress = VK_TRUE;
+    }
+
+    DxvkNameSet extensionsEnabled;
+
+    if (!m_deviceExtensions.enableExtensions(
+          devExtensionList.size(),
+          devExtensionList.data(),
+          &extensionsEnabled))
+      throw DxvkError("DxvkAdapter: Failed to create device");
+    
+    // Enable additional extensions if necessary
+    extensionsEnabled.merge(m_extraExtensions);
+    DxvkNameList extensionNameList = extensionsEnabled.toNameList();
+
+    // Always enable robust buffer access
+    enabledFeatures.core.features.robustBufferAccess = VK_TRUE;
+
+    // Enable variable multisample rate if supported
+    enabledFeatures.core.features.variableMultisampleRate =
+      m_deviceFeatures.core.features.variableMultisampleRate;
+
+    // Always enable memory model so client APIs can use it
+    enabledFeatures.vk12.vulkanMemoryModel = VK_TRUE;
+
+    // Optionally used by some client API extensions
+    enabledFeatures.vk12.drawIndirectCount =
+      m_deviceFeatures.vk12.drawIndirectCount;
+
+    // Required since we no longer have a fallback for GPU queries
+    enabledFeatures.vk12.hostQueryReset = VK_TRUE;
+
+    // Used by some internal shaders, and can be used by applications
+    enabledFeatures.vk12.shaderOutputViewportIndex =
+      m_deviceFeatures.vk12.shaderOutputViewportIndex;
+    enabledFeatures.vk12.shaderOutputLayer =
+      m_deviceFeatures.vk12.shaderOutputLayer;
+
+    // Required for proper GPU synchronization
+    enabledFeatures.vk12.timelineSemaphore = VK_TRUE;
+
+    // Only enable the base image robustness feature if robustness 2 isn't
+    // supported, since this is only a subset of what we actually want.
+    enabledFeatures.vk13.robustImageAccess =
+      m_deviceFeatures.vk13.robustImageAccess &&
+      !m_deviceFeatures.extRobustness2.robustImageAccess2;
+
+    // Only used in combination with pipeline libraries
+    // right now, but enabling it won't hurt anyway
+    enabledFeatures.vk13.pipelineCreationCacheControl =
+      m_deviceFeatures.vk13.pipelineCreationCacheControl;
+
+    // Core features that we're relying on in various places
+    enabledFeatures.vk13.synchronization2 = VK_TRUE;
+    enabledFeatures.vk13.dynamicRendering = VK_TRUE;
+
+    // We expose depth clip rather than depth clamp to client APIs
+    enabledFeatures.extDepthClipEnable.depthClipEnable =
+      m_deviceFeatures.extDepthClipEnable.depthClipEnable;
+
+    // Used to make pipeline library stuff less clunky
+    enabledFeatures.extExtendedDynamicState3.extendedDynamicState3AlphaToCoverageEnable =
+      m_deviceFeatures.extExtendedDynamicState3.extendedDynamicState3AlphaToCoverageEnable;
+    enabledFeatures.extExtendedDynamicState3.extendedDynamicState3DepthClipEnable =
+      m_deviceFeatures.extExtendedDynamicState3.extendedDynamicState3DepthClipEnable &&
+      m_deviceFeatures.extDepthClipEnable.depthClipEnable;
+    enabledFeatures.extExtendedDynamicState3.extendedDynamicState3RasterizationSamples =
+      m_deviceFeatures.extExtendedDynamicState3.extendedDynamicState3RasterizationSamples;
+    enabledFeatures.extExtendedDynamicState3.extendedDynamicState3SampleMask =
+      m_deviceFeatures.extExtendedDynamicState3.extendedDynamicState3SampleMask;
+    enabledFeatures.extExtendedDynamicState3.extendedDynamicState3LineRasterizationMode =
+      m_deviceFeatures.extExtendedDynamicState3.extendedDynamicState3LineRasterizationMode;
+
+    // Used for both pNext shader module info, and fast-linking pipelines provided
+    // that graphicsPipelineLibraryIndependentInterpolationDecoration is supported
+    enabledFeatures.extGraphicsPipelineLibrary.graphicsPipelineLibrary =
+      m_deviceFeatures.extGraphicsPipelineLibrary.graphicsPipelineLibrary;
+
+    // Only enable non-default line rasterization features if at least wide lines
+    // and rectangular lines are supported. This saves us several feature checks
+    // in the actual code.
+    if (m_deviceFeatures.core.features.wideLines && m_deviceFeatures.extLineRasterization.rectangularLines) {
+      enabledFeatures.core.features.wideLines = VK_TRUE;
+      enabledFeatures.extLineRasterization.rectangularLines = VK_TRUE;
+      enabledFeatures.extLineRasterization.smoothLines =
+        m_deviceFeatures.extLineRasterization.smoothLines;
+    }
+
+    // Enable memory priority if supported to improve memory management
+    enabledFeatures.extMemoryPriority.memoryPriority =
+      m_deviceFeatures.extMemoryPriority.memoryPriority;
+
+    // Require robustBufferAccess2 since we use the robustness alignment
+    // info in a number of places, and require null descriptor support
+    // since we no longer have a fallback for those in the backend
+    enabledFeatures.extRobustness2.robustBufferAccess2 = VK_TRUE;
+    enabledFeatures.extRobustness2.robustImageAccess2 = m_deviceFeatures.extRobustness2.robustImageAccess2;
+    enabledFeatures.extRobustness2.nullDescriptor = VK_TRUE;
+
+    // We use this to avoid decompressing SPIR-V shaders in some situations
+    enabledFeatures.extShaderModuleIdentifier.shaderModuleIdentifier =
+      m_deviceFeatures.extShaderModuleIdentifier.shaderModuleIdentifier;
+
+    // Enable swap chain features that are transparent tot he device
+    enabledFeatures.extSwapchainMaintenance1.swapchainMaintenance1 =
+      m_deviceFeatures.extSwapchainMaintenance1.swapchainMaintenance1 &&
+      instance->extensions().extSurfaceMaintenance1;
+
+    // Enable maintenance5 if supported
+    enabledFeatures.khrMaintenance5.maintenance5 =
+      m_deviceFeatures.khrMaintenance5.maintenance5;
+
+    // Enable present id and present wait together, if possible
+    enabledFeatures.khrPresentId.presentId =
+      m_deviceFeatures.khrPresentId.presentId;
+    enabledFeatures.khrPresentWait.presentWait =
+      m_deviceFeatures.khrPresentId.presentId &&
+      m_deviceFeatures.khrPresentWait.presentWait;
+
+    // Unless we're on an Nvidia driver where these extensions are known to be broken
+    if (matchesDriver(VK_DRIVER_ID_NVIDIA_PROPRIETARY, 0, VK_MAKE_VERSION(535, 0, 0))) {
+      enabledFeatures.khrPresentId.presentId = VK_FALSE;
+      enabledFeatures.khrPresentWait.presentWait = VK_FALSE;
+    }
+
+    // Enable raw access chains for shader backends
+    enabledFeatures.nvRawAccessChains.shaderRawAccessChains =
+      m_deviceFeatures.nvRawAccessChains.shaderRawAccessChains;
+
+    // Create pNext chain for additional device features
+    initFeatureChain(enabledFeatures, devExtensions, instance->extensions());
+
+    // Log feature support info an extension list
+    Logger::info(str::format("Device properties:"
+      "\n  Device : ", m_deviceInfo.core.properties.deviceName,
+      "\n  Driver : ", m_deviceInfo.vk12.driverName, " ",
+      VK_VERSION_MAJOR(m_deviceInfo.core.properties.driverVersion), ".",
+      VK_VERSION_MINOR(m_deviceInfo.core.properties.driverVersion), ".",
+      VK_VERSION_PATCH(m_deviceInfo.core.properties.driverVersion)));
+
+    Logger::info("Enabled device extensions:");
+    this->logNameList(extensionNameList);
+    this->logFeatures(enabledFeatures);
+
+    // Report the desired overallocation behaviour to the driver
+    VkDeviceMemoryOverallocationCreateInfoAMD overallocInfo = { VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD };
+    overallocInfo.overallocationBehavior = VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD;
+
+    // Create the requested queues
+    float queuePriority = 1.0f;
+    std::vector<VkDeviceQueueCreateInfo> queueInfos;
+
+    std::unordered_set<uint32_t> queueFamiliySet;
+
+    DxvkAdapterQueueIndices queueFamilies = findQueueFamilies();
+    queueFamiliySet.insert(queueFamilies.graphics);
+    queueFamiliySet.insert(queueFamilies.transfer);
+
+    if (queueFamilies.sparse != VK_QUEUE_FAMILY_IGNORED)
+      queueFamiliySet.insert(queueFamilies.sparse);
+
+    this->logQueueFamilies(queueFamilies);
+    
+    for (uint32_t family : queueFamiliySet) {
+      VkDeviceQueueCreateInfo graphicsQueue = { VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO };
+      graphicsQueue.queueFamilyIndex  = family;
+      graphicsQueue.queueCount        = 1;
+      graphicsQueue.pQueuePriorities  = &queuePriority;
+      queueInfos.push_back(graphicsQueue);
+    }
+
+    VkDeviceCreateInfo info = { VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, enabledFeatures.core.pNext };
+    info.queueCreateInfoCount       = queueInfos.size();
+    info.pQueueCreateInfos          = queueInfos.data();
+    info.enabledExtensionCount      = extensionNameList.count();
+    info.ppEnabledExtensionNames    = extensionNameList.names();
+    info.pEnabledFeatures           = &enabledFeatures.core.features;
+
+    if (devExtensions.amdMemoryOverallocationBehaviour)
+      overallocInfo.pNext = std::exchange(info.pNext, &overallocInfo);
+    
+    VkDevice device = VK_NULL_HANDLE;
+    VkResult vr = m_vki->vkCreateDevice(m_handle, &info, nullptr, &device);
+
+    if (vr != VK_SUCCESS && enableCudaInterop) {
+      // Enabling certain Vulkan extensions can cause device creation to fail on
+      // Nvidia drivers if a certain kernel module isn't loaded, but we cannot know
+      // that in advance since the extensions are reported as supported anyway.
+      Logger::err("DxvkAdapter: Failed to create device, retrying without CUDA interop extensions");
+
+      extensionsEnabled.disableExtension(devExtensions.nvxBinaryImport);
+      extensionsEnabled.disableExtension(devExtensions.nvxImageViewHandle);
+
+      enabledFeatures.vk12.bufferDeviceAddress = VK_FALSE;
+
+      extensionNameList = extensionsEnabled.toNameList();
+      info.enabledExtensionCount      = extensionNameList.count();
+      info.ppEnabledExtensionNames    = extensionNameList.names();
+
+      vr = m_vki->vkCreateDevice(m_handle, &info, nullptr, &device);
+    }
+
+    if (vr != VK_SUCCESS)
+      throw DxvkError("DxvkAdapter: Failed to create device");
+    
+    Rc<vk::DeviceFn> vkd = new vk::DeviceFn(m_vki, true, device);
+
+    DxvkDeviceQueueSet queues = { };
+    queues.graphics = getDeviceQueue(vkd, queueFamilies.graphics, 0);
+    queues.transfer = getDeviceQueue(vkd, queueFamilies.transfer, 0);
+    queues.sparse = getDeviceQueue(vkd, queueFamilies.sparse, 0);
+
+    return new DxvkDevice(instance, this, vkd, enabledFeatures, queues, DxvkQueueCallback());
+  }
+
+
+  Rc<DxvkDevice> DxvkAdapter::importDevice(
+    const Rc<DxvkInstance>&   instance,
+    const DxvkDeviceImportInfo& args) {
+    DxvkDeviceExtensions devExtensions;
+    auto devExtensionList = getExtensionList(devExtensions);
+
+    if (!m_deviceExtensions.enableExtensions(devExtensionList.size(), devExtensionList.data(), nullptr))
+      throw DxvkError("DxvkAdapter: Failed to create device");
+    
+    DxvkNameList extensionNameList(args.extensionCount, args.extensionNames);
+
+    // Populate feature structs based on imported Vulkan device
+    DxvkDeviceFeatures enabledFeatures = { };
+
+    for (auto f = reinterpret_cast<const VkBaseOutStructure*>(args.features); f; f = f->pNext) {
+      switch (f->sType) {
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
+          enabledFeatures.core.features = reinterpret_cast<const VkPhysicalDeviceFeatures2*>(f)->features;
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
+          enabledFeatures.vk11 = *reinterpret_cast<const VkPhysicalDeviceVulkan11Features*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
+          enabledFeatures.vk12 = *reinterpret_cast<const VkPhysicalDeviceVulkan12Features*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
+          enabledFeatures.vk13 = *reinterpret_cast<const VkPhysicalDeviceVulkan13Features*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
+          enabledFeatures.extAttachmentFeedbackLoopLayout = *reinterpret_cast<const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
+          enabledFeatures.extCustomBorderColor = *reinterpret_cast<const VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
+          enabledFeatures.extDepthClipEnable = *reinterpret_cast<const VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
+          enabledFeatures.extDepthBiasControl = *reinterpret_cast<const VkPhysicalDeviceDepthBiasControlFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
+          enabledFeatures.extExtendedDynamicState3 = *reinterpret_cast<const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
+          enabledFeatures.extFragmentShaderInterlock = *reinterpret_cast<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
+          enabledFeatures.extGraphicsPipelineLibrary = *reinterpret_cast<const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
+          enabledFeatures.extLineRasterization = *reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
+          enabledFeatures.extMemoryPriority = *reinterpret_cast<const VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
+          enabledFeatures.extNonSeamlessCubeMap = *reinterpret_cast<const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
+          enabledFeatures.extRobustness2 = *reinterpret_cast<const VkPhysicalDeviceRobustness2FeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
+          enabledFeatures.extShaderModuleIdentifier = *reinterpret_cast<const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
+          enabledFeatures.extSwapchainMaintenance1 = *reinterpret_cast<const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
+          enabledFeatures.extTransformFeedback = *reinterpret_cast<const VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
+          enabledFeatures.extVertexAttributeDivisor = *reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR:
+          enabledFeatures.khrMaintenance5 = *reinterpret_cast<const VkPhysicalDeviceMaintenance5FeaturesKHR*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
+          enabledFeatures.khrPresentId = *reinterpret_cast<const VkPhysicalDevicePresentIdFeaturesKHR*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
+          enabledFeatures.khrPresentWait = *reinterpret_cast<const VkPhysicalDevicePresentWaitFeaturesKHR*>(f);
+          break;
+
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV:
+          enabledFeatures.nvRawAccessChains = *reinterpret_cast<const VkPhysicalDeviceRawAccessChainsFeaturesNV*>(f);
+          break;
+
+        default:
+          // Ignore any unknown feature structs
+          break;
+      }
+    }
+
+    initFeatureChain(enabledFeatures, devExtensions, instance->extensions());
+
+    // Log feature support info an extension list
+    Logger::info(str::format("Device properties:"
+      "\n  Device name: ", m_deviceInfo.core.properties.deviceName,
+      "\n  Driver:      ", m_deviceInfo.vk12.driverName, " ",
+      VK_VERSION_MAJOR(m_deviceInfo.core.properties.driverVersion), ".",
+      VK_VERSION_MINOR(m_deviceInfo.core.properties.driverVersion), ".",
+      VK_VERSION_PATCH(m_deviceInfo.core.properties.driverVersion)));
+
+    Logger::info("Enabled device extensions:");
+    this->logNameList(extensionNameList);
+    this->logFeatures(enabledFeatures);
+
+    // Create device loader
+    Rc<vk::DeviceFn> vkd = new vk::DeviceFn(m_vki, false, args.device);
+
+    // We only support one queue when importing devices, and no sparse.
+    DxvkDeviceQueueSet queues = { };
+    queues.graphics = { args.queue, args.queueFamily };
+    queues.transfer = queues.graphics;
+
+    return new DxvkDevice(instance, this, vkd, enabledFeatures, queues, args.queueCallback);
+  }
+
+
+  void DxvkAdapter::notifyMemoryAlloc(
+          uint32_t            heap,
+          int64_t             bytes) {
+    if (heap < m_memoryAllocated.size())
+      m_memoryAllocated[heap] += bytes;
+  }
+
+
+  void DxvkAdapter::notifyMemoryUse(
+          uint32_t            heap,
+          int64_t             bytes) {
+    if (heap < m_memoryUsed.size())
+      m_memoryUsed[heap] += bytes;
+  }
+
+
+  bool DxvkAdapter::matchesDriver(
+          VkDriverIdKHR       driver,
+          uint32_t            minVer,
+          uint32_t            maxVer) const {
+    bool driverMatches = driver == m_deviceInfo.vk12.driverID;
+
+    if (minVer) driverMatches &= m_deviceInfo.core.properties.driverVersion >= minVer;
+    if (maxVer) driverMatches &= m_deviceInfo.core.properties.driverVersion <  maxVer;
+
+    return driverMatches;
+  }
+  
+  
+  void DxvkAdapter::logAdapterInfo() const {
+    const auto deviceInfo = this->devicePropertiesExt();
+    const auto memoryInfo = this->memoryProperties();
+    
+    Logger::info(str::format(deviceInfo.core.properties.deviceName, ":",
+      "\n  Driver : ", deviceInfo.vk12.driverName, " ",
+      VK_VERSION_MAJOR(deviceInfo.core.properties.driverVersion), ".",
+      VK_VERSION_MINOR(deviceInfo.core.properties.driverVersion), ".",
+      VK_VERSION_PATCH(deviceInfo.core.properties.driverVersion)));
+
+    for (uint32_t i = 0; i < memoryInfo.memoryHeapCount; i++) {
+      constexpr VkDeviceSize mib = 1024 * 1024;
+      
+      Logger::info(str::format("  Memory Heap[", i, "]: "));
+      Logger::info(str::format("    Size: ", memoryInfo.memoryHeaps[i].size / mib, " MiB"));
+      Logger::info(str::format("    Flags: ", "0x", std::hex, memoryInfo.memoryHeaps[i].flags));
+      
+      for (uint32_t j = 0; j < memoryInfo.memoryTypeCount; j++) {
+        if (memoryInfo.memoryTypes[j].heapIndex == i) {
+          Logger::info(str::format(
+            "    Memory Type[", j, "]: ",
+            "Property Flags = ", "0x", std::hex, memoryInfo.memoryTypes[j].propertyFlags));
+        }
+      }
+    }
+  }
+  
+  
+  bool DxvkAdapter::isUnifiedMemoryArchitecture() const {
+    auto memory = this->memoryProperties();
+    bool result = true;
+
+    for (uint32_t i = 0; i < memory.memoryHeapCount; i++)
+      result &= memory.memoryHeaps[i].flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT;
+
+    return result;
+  }
+  
+  
+  void DxvkAdapter::queryExtensions() {
+    m_deviceExtensions = DxvkNameSet::enumDeviceExtensions(m_vki, m_handle);
+  }
+
+
+  void DxvkAdapter::queryDeviceInfo() {
+    m_deviceInfo = DxvkDeviceInfo();
+    m_deviceInfo.core.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
+    m_deviceInfo.core.pNext = nullptr;
+
+    // Query info now so that we have basic device properties available
+    m_vki->vkGetPhysicalDeviceProperties2(m_handle, &m_deviceInfo.core);
+
+    m_deviceInfo.vk11.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;
+    m_deviceInfo.vk11.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.vk11);
+
+    m_deviceInfo.vk12.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES;
+    m_deviceInfo.vk12.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.vk12);
+
+    m_deviceInfo.vk13.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
+    m_deviceInfo.vk13.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.vk13);
+
+    if (m_deviceExtensions.supports(VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME)) {
+      m_deviceInfo.extConservativeRasterization.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
+      m_deviceInfo.extConservativeRasterization.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.extConservativeRasterization);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME)) {
+      m_deviceInfo.extCustomBorderColor.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
+      m_deviceInfo.extCustomBorderColor.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.extCustomBorderColor);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME)) {
+      m_deviceInfo.extExtendedDynamicState3.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT;
+      m_deviceInfo.extExtendedDynamicState3.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.extExtendedDynamicState3);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME)) {
+      m_deviceInfo.extGraphicsPipelineLibrary.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT;
+      m_deviceInfo.extGraphicsPipelineLibrary.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.extGraphicsPipelineLibrary);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME)) {
+      m_deviceInfo.extLineRasterization.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT;
+      m_deviceInfo.extLineRasterization.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.extLineRasterization);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_ROBUSTNESS_2_EXTENSION_NAME)) {
+      m_deviceInfo.extRobustness2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT;
+      m_deviceInfo.extRobustness2.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.extRobustness2);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME)) {
+      m_deviceInfo.extTransformFeedback.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
+      m_deviceInfo.extTransformFeedback.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.extTransformFeedback);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME)) {
+      m_deviceInfo.extVertexAttributeDivisor.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
+      m_deviceInfo.extVertexAttributeDivisor.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.extVertexAttributeDivisor);
+    }
+
+    if (m_deviceExtensions.supports(VK_KHR_MAINTENANCE_5_EXTENSION_NAME)) {
+      m_deviceInfo.khrMaintenance5.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR;
+      m_deviceInfo.khrMaintenance5.pNext = std::exchange(m_deviceInfo.core.pNext, &m_deviceInfo.khrMaintenance5);
+    }
+
+    // Query full device properties for all enabled extensions
+    m_vki->vkGetPhysicalDeviceProperties2(m_handle, &m_deviceInfo.core);
+    
+    // Some drivers reports the driver version in a slightly different format
+    switch (m_deviceInfo.vk12.driverID) {
+      case VK_DRIVER_ID_NVIDIA_PROPRIETARY:
+        m_deviceInfo.core.properties.driverVersion = VK_MAKE_VERSION(
+          (m_deviceInfo.core.properties.driverVersion >> 22) & 0x3ff,
+          (m_deviceInfo.core.properties.driverVersion >> 14) & 0x0ff,
+          (m_deviceInfo.core.properties.driverVersion >>  6) & 0x0ff);
+        break;
+
+      case VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS:
+        m_deviceInfo.core.properties.driverVersion = VK_MAKE_VERSION(
+          m_deviceInfo.core.properties.driverVersion >> 14,
+          m_deviceInfo.core.properties.driverVersion & 0x3fff, 0);
+        break;
+
+      default:;
+    }
+  }
+
+
+  void DxvkAdapter::queryDeviceFeatures() {
+    m_deviceFeatures = DxvkDeviceFeatures();
+    m_deviceFeatures.core.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
+    m_deviceFeatures.core.pNext = nullptr;
+
+    m_deviceFeatures.vk11.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
+    m_deviceFeatures.vk11.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.vk11);
+
+    m_deviceFeatures.vk12.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
+    m_deviceFeatures.vk12.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.vk12);
+
+    m_deviceFeatures.vk13.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
+    m_deviceFeatures.vk13.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.vk13);
+
+    if (m_deviceExtensions.supports(VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME))
+      m_deviceFeatures.amdShaderFragmentMask = VK_TRUE;
+
+    if (m_deviceExtensions.supports(VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME)) {
+      m_deviceFeatures.extAttachmentFeedbackLoopLayout.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
+      m_deviceFeatures.extAttachmentFeedbackLoopLayout.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extAttachmentFeedbackLoopLayout);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME))
+      m_deviceFeatures.extConservativeRasterization = VK_TRUE;
+
+    if (m_deviceExtensions.supports(VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME)) {
+      m_deviceFeatures.extCustomBorderColor.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
+      m_deviceFeatures.extCustomBorderColor.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extCustomBorderColor);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME)) {
+      m_deviceFeatures.extDepthClipEnable.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
+      m_deviceFeatures.extDepthClipEnable.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extDepthClipEnable);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME)) {
+      m_deviceFeatures.extDepthBiasControl.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
+      m_deviceFeatures.extDepthBiasControl.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extDepthBiasControl);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME)) {
+      m_deviceFeatures.extExtendedDynamicState3.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
+      m_deviceFeatures.extExtendedDynamicState3.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extExtendedDynamicState3);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME)) {
+      m_deviceFeatures.extFragmentShaderInterlock.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
+      m_deviceFeatures.extFragmentShaderInterlock.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extFragmentShaderInterlock);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME))
+      m_deviceFeatures.extFullScreenExclusive = VK_TRUE;
+
+    if (m_deviceExtensions.supports(VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME)) {
+      m_deviceFeatures.extGraphicsPipelineLibrary.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
+      m_deviceFeatures.extGraphicsPipelineLibrary.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extGraphicsPipelineLibrary);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME)) {
+      m_deviceFeatures.extLineRasterization.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT;
+      m_deviceFeatures.extLineRasterization.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extLineRasterization);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_MEMORY_BUDGET_EXTENSION_NAME))
+      m_deviceFeatures.extMemoryBudget = VK_TRUE;
+
+    if (m_deviceExtensions.supports(VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME)) {
+      m_deviceFeatures.extMemoryPriority.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
+      m_deviceFeatures.extMemoryPriority.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extMemoryPriority);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME)) {
+      m_deviceFeatures.extNonSeamlessCubeMap.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
+      m_deviceFeatures.extNonSeamlessCubeMap.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extNonSeamlessCubeMap);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_ROBUSTNESS_2_EXTENSION_NAME)) {
+      m_deviceFeatures.extRobustness2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT;
+      m_deviceFeatures.extRobustness2.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extRobustness2);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME)) {
+      m_deviceFeatures.extShaderModuleIdentifier.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
+      m_deviceFeatures.extShaderModuleIdentifier.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extShaderModuleIdentifier);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME))
+      m_deviceFeatures.extShaderStencilExport = VK_TRUE;
+
+    if (m_deviceExtensions.supports(VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME))
+      m_deviceFeatures.extSwapchainColorSpace = VK_TRUE;
+
+    if (m_deviceExtensions.supports(VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME)) {
+      m_deviceFeatures.extSwapchainMaintenance1.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT;
+      m_deviceFeatures.extSwapchainMaintenance1.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extSwapchainMaintenance1);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_HDR_METADATA_EXTENSION_NAME))
+      m_deviceFeatures.extHdrMetadata = VK_TRUE;
+
+    if (m_deviceExtensions.supports(VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME)) {
+      m_deviceFeatures.extTransformFeedback.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
+      m_deviceFeatures.extTransformFeedback.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extTransformFeedback);
+    }
+
+    if (m_deviceExtensions.supports(VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME) >= 3) {
+      m_deviceFeatures.extVertexAttributeDivisor.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
+      m_deviceFeatures.extVertexAttributeDivisor.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.extVertexAttributeDivisor);
+    }
+
+    if (m_deviceExtensions.supports(VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME))
+      m_deviceFeatures.khrExternalMemoryWin32 = VK_TRUE;
+
+    if (m_deviceExtensions.supports(VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME))
+      m_deviceFeatures.khrExternalSemaphoreWin32 = VK_TRUE;
+
+    if (m_deviceExtensions.supports(VK_KHR_MAINTENANCE_5_EXTENSION_NAME)) {
+      m_deviceFeatures.khrMaintenance5.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR;
+      m_deviceFeatures.khrMaintenance5.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.khrMaintenance5);
+    }
+
+    if (m_deviceExtensions.supports(VK_KHR_PRESENT_ID_EXTENSION_NAME)) {
+      m_deviceFeatures.khrPresentId.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
+      m_deviceFeatures.khrPresentId.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.khrPresentId);
+    }
+
+    if (m_deviceExtensions.supports(VK_KHR_PRESENT_WAIT_EXTENSION_NAME)) {
+      m_deviceFeatures.khrPresentWait.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
+      m_deviceFeatures.khrPresentWait.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.khrPresentWait);
+    }
+
+    if (m_deviceExtensions.supports(VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME)) {
+      m_deviceFeatures.nvRawAccessChains.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV;
+      m_deviceFeatures.nvRawAccessChains.pNext = std::exchange(m_deviceFeatures.core.pNext, &m_deviceFeatures.nvRawAccessChains);
+    }
+
+    if (m_deviceExtensions.supports(VK_NVX_BINARY_IMPORT_EXTENSION_NAME))
+      m_deviceFeatures.nvxBinaryImport = VK_TRUE;
+
+    if (m_deviceExtensions.supports(VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME))
+      m_deviceFeatures.nvxImageViewHandle = VK_TRUE;
+
+    m_vki->vkGetPhysicalDeviceFeatures2(m_handle, &m_deviceFeatures.core);
+  }
+
+
+  void DxvkAdapter::queryDeviceQueues() {
+    uint32_t numQueueFamilies = 0;
+    m_vki->vkGetPhysicalDeviceQueueFamilyProperties(
+      m_handle, &numQueueFamilies, nullptr);
+    
+    m_queueFamilies.resize(numQueueFamilies);
+    m_vki->vkGetPhysicalDeviceQueueFamilyProperties(
+      m_handle, &numQueueFamilies, m_queueFamilies.data());
+  }
+
+
+  uint32_t DxvkAdapter::findQueueFamily(
+          VkQueueFlags          mask,
+          VkQueueFlags          flags) const {
+    for (uint32_t i = 0; i < m_queueFamilies.size(); i++) {
+      if ((m_queueFamilies[i].queueFlags & mask) == flags)
+        return i;
+    }
+
+    return VK_QUEUE_FAMILY_IGNORED;
+  }
+
+
+  std::vector<DxvkExt*> DxvkAdapter::getExtensionList(
+          DxvkDeviceExtensions&   devExtensions) {
+    return {{
+      &devExtensions.amdMemoryOverallocationBehaviour,
+      &devExtensions.amdShaderFragmentMask,
+      &devExtensions.extAttachmentFeedbackLoopLayout,
+      &devExtensions.extConservativeRasterization,
+      &devExtensions.extCustomBorderColor,
+      &devExtensions.extDepthClipEnable,
+      &devExtensions.extDepthBiasControl,
+      &devExtensions.extExtendedDynamicState3,
+      &devExtensions.extFragmentShaderInterlock,
+      &devExtensions.extFullScreenExclusive,
+      &devExtensions.extGraphicsPipelineLibrary,
+      &devExtensions.extHdrMetadata,
+      &devExtensions.extLineRasterization,
+      &devExtensions.extMemoryBudget,
+      &devExtensions.extMemoryPriority,
+      &devExtensions.extNonSeamlessCubeMap,
+      &devExtensions.extRobustness2,
+      &devExtensions.extShaderModuleIdentifier,
+      &devExtensions.extShaderStencilExport,
+      &devExtensions.extSwapchainColorSpace,
+      &devExtensions.extSwapchainMaintenance1,
+      &devExtensions.extTransformFeedback,
+      &devExtensions.extVertexAttributeDivisor,
+      &devExtensions.khrExternalMemoryWin32,
+      &devExtensions.khrExternalSemaphoreWin32,
+      &devExtensions.khrMaintenance5,
+      &devExtensions.khrPipelineLibrary,
+      &devExtensions.khrPresentId,
+      &devExtensions.khrPresentWait,
+      &devExtensions.khrSwapchain,
+      &devExtensions.khrWin32KeyedMutex,
+      &devExtensions.nvRawAccessChains,
+      &devExtensions.nvxBinaryImport,
+      &devExtensions.nvxImageViewHandle,
+    }};
+  }
+
+
+  void DxvkAdapter::initFeatureChain(
+          DxvkDeviceFeatures&   enabledFeatures,
+    const DxvkDeviceExtensions& devExtensions,
+    const DxvkInstanceExtensions& insExtensions) {
+    enabledFeatures.core.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR;
+    enabledFeatures.core.pNext = nullptr;
+
+    enabledFeatures.vk11.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
+    enabledFeatures.vk11.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.vk11);
+
+    enabledFeatures.vk12.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
+    enabledFeatures.vk12.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.vk12);
+
+    enabledFeatures.vk13.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
+    enabledFeatures.vk13.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.vk13);
+
+    if (devExtensions.amdShaderFragmentMask)
+      enabledFeatures.amdShaderFragmentMask = VK_TRUE;
+
+    if (devExtensions.extAttachmentFeedbackLoopLayout) {
+      enabledFeatures.extAttachmentFeedbackLoopLayout.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
+      enabledFeatures.extAttachmentFeedbackLoopLayout.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extAttachmentFeedbackLoopLayout);
+    }
+
+    if (devExtensions.extConservativeRasterization)
+      enabledFeatures.extConservativeRasterization = VK_TRUE;
+
+    if (devExtensions.extCustomBorderColor) {
+      enabledFeatures.extCustomBorderColor.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
+      enabledFeatures.extCustomBorderColor.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extCustomBorderColor);
+    }
+
+    if (devExtensions.extDepthClipEnable) {
+      enabledFeatures.extDepthClipEnable.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
+      enabledFeatures.extDepthClipEnable.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extDepthClipEnable);
+    }
+
+    if (devExtensions.extDepthBiasControl) {
+      enabledFeatures.extDepthBiasControl.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
+      enabledFeatures.extDepthBiasControl.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extDepthBiasControl);
+    }
+
+    if (devExtensions.extExtendedDynamicState3) {
+      enabledFeatures.extExtendedDynamicState3.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
+      enabledFeatures.extExtendedDynamicState3.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extExtendedDynamicState3);
+    }
+
+    if (devExtensions.extFragmentShaderInterlock) {
+      enabledFeatures.extFragmentShaderInterlock.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
+      enabledFeatures.extFragmentShaderInterlock.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extFragmentShaderInterlock);
+    }
+
+    if (devExtensions.extFullScreenExclusive && insExtensions.khrGetSurfaceCapabilities2)
+      enabledFeatures.extFullScreenExclusive = VK_TRUE;
+
+    if (devExtensions.extGraphicsPipelineLibrary) {
+      enabledFeatures.extGraphicsPipelineLibrary.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
+      enabledFeatures.extGraphicsPipelineLibrary.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extGraphicsPipelineLibrary);
+    }
+
+    if (devExtensions.extLineRasterization) {
+      enabledFeatures.extLineRasterization.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT;
+      enabledFeatures.extLineRasterization.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extLineRasterization);
+    }
+
+    if (devExtensions.extMemoryBudget)
+      enabledFeatures.extMemoryBudget = VK_TRUE;
+
+    if (devExtensions.extMemoryPriority) {
+      enabledFeatures.extMemoryPriority.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
+      enabledFeatures.extMemoryPriority.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extMemoryPriority);
+    }
+
+    if (devExtensions.extNonSeamlessCubeMap) {
+      enabledFeatures.extNonSeamlessCubeMap.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
+      enabledFeatures.extNonSeamlessCubeMap.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extNonSeamlessCubeMap);
+    }
+
+    if (devExtensions.extShaderModuleIdentifier) {
+      enabledFeatures.extShaderModuleIdentifier.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
+      enabledFeatures.extShaderModuleIdentifier.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extShaderModuleIdentifier);
+    }
+
+    if (devExtensions.extRobustness2) {
+      enabledFeatures.extRobustness2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT;
+      enabledFeatures.extRobustness2.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extRobustness2);
+    }
+
+    if (devExtensions.extShaderStencilExport)
+      enabledFeatures.extShaderStencilExport = VK_TRUE;
+
+    if (devExtensions.extSwapchainColorSpace)
+      enabledFeatures.extSwapchainColorSpace = VK_TRUE;
+
+    if (devExtensions.extSwapchainMaintenance1) {
+      enabledFeatures.extSwapchainMaintenance1.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT;
+      enabledFeatures.extSwapchainMaintenance1.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extSwapchainMaintenance1);
+    }
+
+    if (devExtensions.extHdrMetadata)
+      enabledFeatures.extHdrMetadata = VK_TRUE;
+
+    if (devExtensions.extTransformFeedback) {
+      enabledFeatures.extTransformFeedback.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
+      enabledFeatures.extTransformFeedback.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extTransformFeedback);
+    }
+
+    if (devExtensions.extVertexAttributeDivisor.revision() >= 3) {
+      enabledFeatures.extVertexAttributeDivisor.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
+      enabledFeatures.extVertexAttributeDivisor.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.extVertexAttributeDivisor);
+    }
+
+    if (devExtensions.khrExternalMemoryWin32)
+      enabledFeatures.khrExternalMemoryWin32 = VK_TRUE;
+
+    if (devExtensions.khrExternalSemaphoreWin32)
+      enabledFeatures.khrExternalSemaphoreWin32 = VK_TRUE;
+
+    if (devExtensions.khrMaintenance5) {
+      enabledFeatures.khrMaintenance5.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR;
+      enabledFeatures.khrMaintenance5.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.khrMaintenance5);
+    }
+
+    if (devExtensions.khrPresentId) {
+      enabledFeatures.khrPresentId.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
+      enabledFeatures.khrPresentId.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.khrPresentId);
+    }
+
+    if (devExtensions.khrPresentWait) {
+      enabledFeatures.khrPresentWait.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
+      enabledFeatures.khrPresentWait.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.khrPresentWait);
+    }
+
+    if (devExtensions.nvRawAccessChains) {
+      enabledFeatures.nvRawAccessChains.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV;
+      enabledFeatures.nvRawAccessChains.pNext = std::exchange(enabledFeatures.core.pNext, &enabledFeatures.nvRawAccessChains);
+    }
+
+    if (devExtensions.nvxBinaryImport)
+      enabledFeatures.nvxBinaryImport = VK_TRUE;
+
+    if (devExtensions.nvxImageViewHandle)
+      enabledFeatures.nvxImageViewHandle = VK_TRUE;
+
+    if (devExtensions.khrWin32KeyedMutex)
+      enabledFeatures.khrWin32KeyedMutex = VK_TRUE;
+  }
+
+  
+  void DxvkAdapter::logNameList(const DxvkNameList& names) {
+    for (uint32_t i = 0; i < names.count(); i++)
+      Logger::info(str::format("  ", names.name(i)));
+  }
+
+
+  void DxvkAdapter::logFeatures(const DxvkDeviceFeatures& features) {
+    Logger::info(str::format("Device features:",
+      "\n  robustBufferAccess                     : ", features.core.features.robustBufferAccess ? "1" : "0",
+      "\n  fullDrawIndexUint32                    : ", features.core.features.fullDrawIndexUint32 ? "1" : "0",
+      "\n  imageCubeArray                         : ", features.core.features.imageCubeArray ? "1" : "0",
+      "\n  independentBlend                       : ", features.core.features.independentBlend ? "1" : "0",
+      "\n  geometryShader                         : ", features.core.features.geometryShader ? "1" : "0",
+      "\n  tessellationShader                     : ", features.core.features.tessellationShader ? "1" : "0",
+      "\n  sampleRateShading                      : ", features.core.features.sampleRateShading ? "1" : "0",
+      "\n  dualSrcBlend                           : ", features.core.features.dualSrcBlend ? "1" : "0",
+      "\n  logicOp                                : ", features.core.features.logicOp ? "1" : "0",
+      "\n  multiDrawIndirect                      : ", features.core.features.multiDrawIndirect ? "1" : "0",
+      "\n  drawIndirectFirstInstance              : ", features.core.features.drawIndirectFirstInstance ? "1" : "0",
+      "\n  depthClamp                             : ", features.core.features.depthClamp ? "1" : "0",
+      "\n  depthBiasClamp                         : ", features.core.features.depthBiasClamp ? "1" : "0",
+      "\n  fillModeNonSolid                       : ", features.core.features.fillModeNonSolid ? "1" : "0",
+      "\n  depthBounds                            : ", features.core.features.depthBounds ? "1" : "0",
+      "\n  wideLines                              : ", features.core.features.wideLines ? "1" : "0",
+      "\n  multiViewport                          : ", features.core.features.multiViewport ? "1" : "0",
+      "\n  samplerAnisotropy                      : ", features.core.features.samplerAnisotropy ? "1" : "0",
+      "\n  textureCompressionBC                   : ", features.core.features.textureCompressionBC ? "1" : "0",
+      "\n  occlusionQueryPrecise                  : ", features.core.features.occlusionQueryPrecise ? "1" : "0",
+      "\n  pipelineStatisticsQuery                : ", features.core.features.pipelineStatisticsQuery ? "1" : "0",
+      "\n  vertexPipelineStoresAndAtomics         : ", features.core.features.vertexPipelineStoresAndAtomics ? "1" : "0",
+      "\n  fragmentStoresAndAtomics               : ", features.core.features.fragmentStoresAndAtomics ? "1" : "0",
+      "\n  shaderImageGatherExtended              : ", features.core.features.shaderImageGatherExtended ? "1" : "0",
+      "\n  shaderClipDistance                     : ", features.core.features.shaderClipDistance ? "1" : "0",
+      "\n  shaderCullDistance                     : ", features.core.features.shaderCullDistance ? "1" : "0",
+      "\n  shaderFloat64                          : ", features.core.features.shaderFloat64 ? "1" : "0",
+      "\n  shaderInt64                            : ", features.core.features.shaderInt64 ? "1" : "0",
+      "\n  variableMultisampleRate                : ", features.core.features.variableMultisampleRate ? "1" : "0",
+      "\n  shaderResourceResidency                : ", features.core.features.shaderResourceResidency ? "1" : "0",
+      "\n  shaderResourceMinLod                   : ", features.core.features.shaderResourceMinLod ? "1" : "0",
+      "\n  sparseBinding                          : ", features.core.features.sparseBinding ? "1" : "0",
+      "\n  sparseResidencyBuffer                  : ", features.core.features.sparseResidencyBuffer ? "1" : "0",
+      "\n  sparseResidencyImage2D                 : ", features.core.features.sparseResidencyImage2D ? "1" : "0",
+      "\n  sparseResidencyImage3D                 : ", features.core.features.sparseResidencyImage3D ? "1" : "0",
+      "\n  sparseResidency2Samples                : ", features.core.features.sparseResidency2Samples ? "1" : "0",
+      "\n  sparseResidency4Samples                : ", features.core.features.sparseResidency4Samples ? "1" : "0",
+      "\n  sparseResidency8Samples                : ", features.core.features.sparseResidency8Samples ? "1" : "0",
+      "\n  sparseResidency16Samples               : ", features.core.features.sparseResidency16Samples ? "1" : "0",
+      "\n  sparseResidencyAliased                 : ", features.core.features.sparseResidencyAliased ? "1" : "0",
+      "\nVulkan 1.1",
+      "\n  shaderDrawParameters                   : ", features.vk11.shaderDrawParameters,
+      "\nVulkan 1.2",
+      "\n  samplerMirrorClampToEdge               : ", features.vk12.samplerMirrorClampToEdge,
+      "\n  drawIndirectCount                      : ", features.vk12.drawIndirectCount,
+      "\n  samplerFilterMinmax                    : ", features.vk12.samplerFilterMinmax,
+      "\n  hostQueryReset                         : ", features.vk12.hostQueryReset,
+      "\n  timelineSemaphore                      : ", features.vk12.timelineSemaphore,
+      "\n  bufferDeviceAddress                    : ", features.vk12.bufferDeviceAddress,
+      "\n  shaderOutputViewportIndex              : ", features.vk12.shaderOutputViewportIndex,
+      "\n  shaderOutputLayer                      : ", features.vk12.shaderOutputLayer,
+      "\n  vulkanMemoryModel                      : ", features.vk12.vulkanMemoryModel,
+      "\nVulkan 1.3",
+      "\n  robustImageAccess                      : ", features.vk13.robustImageAccess,
+      "\n  pipelineCreationCacheControl           : ", features.vk13.pipelineCreationCacheControl,
+      "\n  shaderDemoteToHelperInvocation         : ", features.vk13.shaderDemoteToHelperInvocation,
+      "\n  shaderZeroInitializeWorkgroupMemory    : ", features.vk13.shaderZeroInitializeWorkgroupMemory,
+      "\n  synchronization2                       : ", features.vk13.synchronization2,
+      "\n  dynamicRendering                       : ", features.vk13.dynamicRendering,
+      "\n", VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.amdShaderFragmentMask ? "1" : "0",
+      "\n", VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME,
+      "\n  attachmentFeedbackLoopLayout           : ", features.extAttachmentFeedbackLoopLayout.attachmentFeedbackLoopLayout ? "1" : "0",
+      "\n", VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.extConservativeRasterization ? "1" : "0",
+      "\n", VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME,
+      "\n  customBorderColors                     : ", features.extCustomBorderColor.customBorderColors ? "1" : "0",
+      "\n  customBorderColorWithoutFormat         : ", features.extCustomBorderColor.customBorderColorWithoutFormat ? "1" : "0",
+      "\n", VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME,
+      "\n  depthClipEnable                        : ", features.extDepthClipEnable.depthClipEnable ? "1" : "0",
+      "\n", VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME,
+      "\n  depthBiasControl                       : ", features.extDepthBiasControl.depthBiasControl ? "1" : "0",
+      "\n  leastRepresentableValueForceUnormRepresentation : ", features.extDepthBiasControl.leastRepresentableValueForceUnormRepresentation ? "1" : "0",
+      "\n  floatRepresentation                    : ", features.extDepthBiasControl.floatRepresentation ? "1" : "0",
+      "\n  depthBiasExact                         : ", features.extDepthBiasControl.depthBiasExact ? "1" : "0",
+      "\n", VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME,
+      "\n  extDynamicState3AlphaToCoverageEnable  : ", features.extExtendedDynamicState3.extendedDynamicState3AlphaToCoverageEnable ? "1" : "0",
+      "\n  extDynamicState3DepthClipEnable        : ", features.extExtendedDynamicState3.extendedDynamicState3DepthClipEnable ? "1" : "0",
+      "\n  extDynamicState3RasterizationSamples   : ", features.extExtendedDynamicState3.extendedDynamicState3RasterizationSamples ? "1" : "0",
+      "\n  extDynamicState3SampleMask             : ", features.extExtendedDynamicState3.extendedDynamicState3SampleMask ? "1" : "0",
+      "\n  extDynamicState3LineRasterizationMode  : ", features.extExtendedDynamicState3.extendedDynamicState3LineRasterizationMode ? "1" : "0",
+      "\n", VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME,
+      "\n  fragmentShaderSampleInterlock          : ", features.extFragmentShaderInterlock.fragmentShaderSampleInterlock ? "1" : "0",
+      "\n  fragmentShaderPixelInterlock           : ", features.extFragmentShaderInterlock.fragmentShaderPixelInterlock ? "1" : "0",
+      "\n", VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.extFullScreenExclusive ? "1" : "0",
+      "\n", VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME,
+      "\n  graphicsPipelineLibrary                : ", features.extGraphicsPipelineLibrary.graphicsPipelineLibrary ? "1" : "0",
+      "\n", VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME,
+      "\n  rectangularLines                       : ", features.extLineRasterization.rectangularLines ? "1" : "0",
+      "\n  smoothLines                            : ", features.extLineRasterization.smoothLines ? "1" : "0",
+      "\n", VK_EXT_MEMORY_BUDGET_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.extMemoryBudget ? "1" : "0",
+      "\n", VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME,
+      "\n  memoryPriority                         : ", features.extMemoryPriority.memoryPriority ? "1" : "0",
+      "\n", VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME,
+      "\n  nonSeamlessCubeMap                     : ", features.extNonSeamlessCubeMap.nonSeamlessCubeMap ? "1" : "0",
+      "\n", VK_EXT_ROBUSTNESS_2_EXTENSION_NAME,
+      "\n  robustBufferAccess2                    : ", features.extRobustness2.robustBufferAccess2 ? "1" : "0",
+      "\n  robustImageAccess2                     : ", features.extRobustness2.robustImageAccess2 ? "1" : "0",
+      "\n  nullDescriptor                         : ", features.extRobustness2.nullDescriptor ? "1" : "0",
+      "\n", VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME,
+      "\n  shaderModuleIdentifier                 : ", features.extShaderModuleIdentifier.shaderModuleIdentifier ? "1" : "0",
+      "\n", VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.extShaderStencilExport ? "1" : "0",
+      "\n", VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.extSwapchainColorSpace ? "1" : "0",
+      "\n", VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME,
+      "\n  swapchainMaintenance1                  : ", features.extSwapchainMaintenance1.swapchainMaintenance1 ? "1" : "0",
+      "\n", VK_EXT_HDR_METADATA_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.extHdrMetadata ? "1" : "0",
+      "\n", VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME,
+      "\n  transformFeedback                      : ", features.extTransformFeedback.transformFeedback ? "1" : "0",
+      "\n  geometryStreams                        : ", features.extTransformFeedback.geometryStreams ? "1" : "0",
+      "\n", VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME,
+      "\n  vertexAttributeInstanceRateDivisor     : ", features.extVertexAttributeDivisor.vertexAttributeInstanceRateDivisor ? "1" : "0",
+      "\n  vertexAttributeInstanceRateZeroDivisor : ", features.extVertexAttributeDivisor.vertexAttributeInstanceRateZeroDivisor ? "1" : "0",
+      "\n", VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.khrExternalMemoryWin32 ? "1" : "0",
+      "\n", VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.khrExternalSemaphoreWin32 ? "1" : "0",
+      "\n", VK_KHR_MAINTENANCE_5_EXTENSION_NAME,
+      "\n  maintenance5                           : ", features.khrMaintenance5.maintenance5 ? "1" : "0",
+      "\n", VK_KHR_PRESENT_ID_EXTENSION_NAME,
+      "\n  presentId                              : ", features.khrPresentId.presentId ? "1" : "0",
+      "\n", VK_KHR_PRESENT_WAIT_EXTENSION_NAME,
+      "\n  presentWait                            : ", features.khrPresentWait.presentWait ? "1" : "0",
+      "\n", VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME,
+      "\n  shaderRawAccessChains                  : ", features.nvRawAccessChains.shaderRawAccessChains ? "1" : "0",
+      "\n", VK_NVX_BINARY_IMPORT_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.nvxBinaryImport ? "1" : "0",
+      "\n", VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.nvxImageViewHandle ? "1" : "0",
+      "\n", VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME,
+      "\n  extension supported                    : ", features.khrWin32KeyedMutex ? "1" : "0"));
+  }
+
+
+  void DxvkAdapter::logQueueFamilies(const DxvkAdapterQueueIndices& queues) {
+    Logger::info(str::format("Queue families:",
+      "\n  Graphics : ", queues.graphics,
+      "\n  Transfer : ", queues.transfer,
+      "\n  Sparse   : ", queues.sparse != VK_QUEUE_FAMILY_IGNORED ? str::format(queues.sparse) : "n/a"));
+  }
+  
+}
diff --git a/src/dxvk/dxvk_adapter.cpp.rej b/src/dxvk/dxvk_adapter.cpp.rej
new file mode 100644
index 00000000..25a58e7b
--- /dev/null
+++ b/src/dxvk/dxvk_adapter.cpp.rej
@@ -0,0 +1,19 @@
+--- src/dxvk/dxvk_adapter.cpp
++++ src/dxvk/dxvk_adapter.cpp
+@@ -997,6 +1000,7 @@ namespace dxvk {
+       &devExtensions.khrPresentWait,
+       &devExtensions.khrSwapchain,
+       &devExtensions.khrWin32KeyedMutex,
++      &devExtensions.nvLowLatency2,
+       &devExtensions.nvxBinaryImport,
+       &devExtensions.nvxImageViewHandle,
+     }};
+@@ -1287,6 +1296,8 @@ namespace dxvk {
+       "\n  presentId                              : ", features.khrPresentId.presentId ? "1" : "0",
+       "\n", VK_KHR_PRESENT_WAIT_EXTENSION_NAME,
+       "\n  presentWait                            : ", features.khrPresentWait.presentWait ? "1" : "0",
++      "\n", VK_NV_LOW_LATENCY_2_EXTENSION_NAME,
++      "\n  extension supported                    : ", features.nvLowLatency2 ? "1" : "0",
+       "\n", VK_NVX_BINARY_IMPORT_EXTENSION_NAME,
+       "\n  extension supported                    : ", features.nvxBinaryImport ? "1" : "0",
+       "\n", VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME,
diff --git a/src/dxvk/dxvk_cmdlist.cpp b/src/dxvk/dxvk_cmdlist.cpp
index 3bd3aa95..54b50ea5 100644
--- a/src/dxvk/dxvk_cmdlist.cpp
+++ b/src/dxvk/dxvk_cmdlist.cpp
@@ -56,10 +56,12 @@ namespace dxvk {
 
   VkResult DxvkCommandSubmission::submit(
           DxvkDevice*           device,
-          VkQueue               queue) {
+          VkQueue               queue,
+          uint64_t              frameId) {
     auto vk = device->vkd();
 
     VkSubmitInfo2 submitInfo = { VK_STRUCTURE_TYPE_SUBMIT_INFO_2 };
+    VkLatencySubmissionPresentIdNV latencySubmitInfo = { VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV };
 
     if (!m_semaphoreWaits.empty()) {
       submitInfo.waitSemaphoreInfoCount = m_semaphoreWaits.size();
@@ -76,6 +78,11 @@ namespace dxvk {
       submitInfo.pSignalSemaphoreInfos = m_semaphoreSignals.data();
     }
 
+    if (device->features().nvLowLatency2 && frameId && !m_commandBuffers.empty()) {
+      latencySubmitInfo.presentID = frameId;
+      latencySubmitInfo.pNext = std::exchange(submitInfo.pNext, &latencySubmitInfo);
+    }
+
     VkResult vr = VK_SUCCESS;
 
     if (!this->isEmpty())
@@ -206,7 +213,7 @@ namespace dxvk {
   }
   
   
-  VkResult DxvkCommandList::submit() {
+  VkResult DxvkCommandList::submit(uint64_t frameId) {
     VkResult status = VK_SUCCESS;
 
     const auto& graphics = m_device->queues().graphics;
@@ -238,7 +245,7 @@ namespace dxvk {
         // for any prior submissions, then block any subsequent ones
         m_commandSubmission.signalSemaphore(m_bindSemaphore, 0, VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT);
 
-        if ((status = m_commandSubmission.submit(m_device, graphics.queueHandle)))
+        if ((status = m_commandSubmission.submit(m_device, graphics.queueHandle, frameId)))
           return status;
 
         sparseBind->waitSemaphore(m_bindSemaphore, 0);
@@ -259,7 +266,7 @@ namespace dxvk {
       if (m_device->hasDedicatedTransferQueue() && !m_commandSubmission.isEmpty()) {
         m_commandSubmission.signalSemaphore(m_sdmaSemaphore, 0, VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT);
 
-        if ((status = m_commandSubmission.submit(m_device, transfer.queueHandle)))
+        if ((status = m_commandSubmission.submit(m_device, transfer.queueHandle, frameId)))
           return status;
 
         m_commandSubmission.waitSemaphore(m_sdmaSemaphore, 0, VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT);
@@ -297,7 +304,7 @@ namespace dxvk {
       }
 
       // Finally, submit all graphics commands of the current submission
-      if ((status = m_commandSubmission.submit(m_device, graphics.queueHandle)))
+      if ((status = m_commandSubmission.submit(m_device, graphics.queueHandle, frameId)))
         return status;
     }
 
diff --git a/src/dxvk/dxvk_cmdlist.h b/src/dxvk/dxvk_cmdlist.h
index 1934b9a0..81b6929d 100644
--- a/src/dxvk/dxvk_cmdlist.h
+++ b/src/dxvk/dxvk_cmdlist.h
@@ -94,7 +94,8 @@ namespace dxvk {
      */
     VkResult submit(
             DxvkDevice*           device,
-            VkQueue               queue);
+            VkQueue               queue,
+            uint64_t              frameId);
 
     /**
      * \brief Resets object
@@ -199,7 +200,7 @@ namespace dxvk {
      * \brief Submits command list
      * \returns Submission status
      */
-    VkResult submit();
+    VkResult submit(uint64_t frameId);
     
     /**
      * \brief Stat counters
diff --git a/src/dxvk/dxvk_context.cpp b/src/dxvk/dxvk_context.cpp
index bbd139ed..034467bd 100644
--- a/src/dxvk/dxvk_context.cpp
+++ b/src/dxvk/dxvk_context.cpp
@@ -105,9 +105,9 @@ namespace dxvk {
   }
 
 
-  void DxvkContext::flushCommandList(DxvkSubmitStatus* status) {
+  void DxvkContext::flushCommandList(DxvkSubmitStatus* status, bool enableFrameId) {
     m_device->submitCommandList(
-      this->endRecording(), status);
+      this->endRecording(), status, enableFrameId);
     
     this->beginRecording(
       m_device->createCommandList());
diff --git a/src/dxvk/dxvk_context.h b/src/dxvk/dxvk_context.h
index b1fbc7df..594ccf54 100644
--- a/src/dxvk/dxvk_context.h
+++ b/src/dxvk/dxvk_context.h
@@ -65,8 +65,9 @@ namespace dxvk {
      * Transparently submits the current command
      * buffer and allocates a new one.
      * \param [out] status Submission feedback
+     * \param [in] enableFrameId Submission should include the frame id
      */
-    void flushCommandList(DxvkSubmitStatus* status);
+    void flushCommandList(DxvkSubmitStatus* status, bool enableFrameId = true);
     
     /**
      * \brief Begins generating query data
diff --git a/src/dxvk/dxvk_device.cpp b/src/dxvk/dxvk_device.cpp
index 9a053791..1e2c34b9 100644
--- a/src/dxvk/dxvk_device.cpp
+++ b/src/dxvk/dxvk_device.cpp
@@ -18,6 +18,7 @@ namespace dxvk {
     m_properties        (adapter->devicePropertiesExt()),
     m_perfHints         (getPerfHints()),
     m_objects           (this),
+    m_latencyMarkers    ({}),
     m_queues            (queues),
     m_submissionQueue   (this, queueCallback) {
 
@@ -271,9 +272,12 @@ namespace dxvk {
 
   void DxvkDevice::submitCommandList(
     const Rc<DxvkCommandList>&      commandList,
-          DxvkSubmitStatus*         status) {
+          DxvkSubmitStatus*         status,
+          bool                      enableFrameId) {
     DxvkSubmitInfo submitInfo = { };
     submitInfo.cmdList = commandList;
+    submitInfo.frameId = enableFrameId ?
+      m_latencyMarkers.render : 0;
     m_submissionQueue.submit(submitInfo, status);
 
     std::lock_guard<sync::Spinlock> statLock(m_statLock);
diff --git a/src/dxvk/dxvk_device.h b/src/dxvk/dxvk_device.h
index a24ee311..305e6e00 100644
--- a/src/dxvk/dxvk_device.h
+++ b/src/dxvk/dxvk_device.h
@@ -66,7 +66,16 @@ namespace dxvk {
     DxvkDeviceQueue transfer;
     DxvkDeviceQueue sparse;
   };
-  
+
+  /**
+   * \brief Latency marker frame ids
+   */
+  struct DxvkDeviceLowLatencyMarkers {
+    uint64_t simulation;
+    uint64_t render;
+    uint64_t present;
+  };
+
   /**
    * \brief DXVK device
    * 
@@ -471,10 +480,12 @@ namespace dxvk {
      * the given set of optional synchronization primitives.
      * \param [in] commandList The command list to submit
      * \param [out] status Submission feedback
+     * \param [in] enableFrameId Submission should include the frame id
      */
     void submitCommandList(
       const Rc<DxvkCommandList>&      commandList,
-            DxvkSubmitStatus*         status);
+            DxvkSubmitStatus*         status,
+            bool                      enableFrameId = true);
 
     /**
      * \brief Locks submission queue
@@ -534,6 +545,44 @@ namespace dxvk {
      * used by the GPU can be safely destroyed.
      */
     void waitForIdle();
+
+    /**
+     * \brief Updates the frame id for the given frame marker
+     * 
+     * \param [in] marker The marker to set the frame ID for
+     * \param [in] id The frame ID to set
+     */
+    void setLatencyMarker(VkLatencyMarkerNV marker, uint64_t id) {
+      switch (marker) {
+        case VK_LATENCY_MARKER_SIMULATION_START_NV:
+          m_latencyMarkers.simulation = id;
+          break;
+        case VK_LATENCY_MARKER_RENDERSUBMIT_START_NV:
+          m_latencyMarkers.render = id;
+          break;
+        case VK_LATENCY_MARKER_PRESENT_START_NV:
+          m_latencyMarkers.present = id;
+          break;
+        default:
+          break;
+      }
+    }
+
+    /**
+     * \brief Resets the latency markers back to zero
+     */
+    void resetLatencyMarkers() {
+      m_latencyMarkers = {};
+    }
+
+    /**
+     * \brief Returns the current set of latency marker frame IDs
+     * 
+     * \returns The current set of frame marker IDs
+     */
+    DxvkDeviceLowLatencyMarkers getLatencyMarkers() {
+      return m_latencyMarkers;
+    }
     
   private:
     
@@ -549,6 +598,8 @@ namespace dxvk {
     DxvkDevicePerfHints         m_perfHints;
     DxvkObjects                 m_objects;
 
+    DxvkDeviceLowLatencyMarkers m_latencyMarkers;
+
     sync::Spinlock              m_statLock;
     DxvkStatCounters            m_statCounters;
     
diff --git a/src/dxvk/dxvk_device_info.h b/src/dxvk/dxvk_device_info.h
index c1da783a..6c315306 100644
--- a/src/dxvk/dxvk_device_info.h
+++ b/src/dxvk/dxvk_device_info.h
@@ -69,9 +69,10 @@ namespace dxvk {
     VkPhysicalDevicePresentIdFeaturesKHR                      khrPresentId;
     VkPhysicalDevicePresentWaitFeaturesKHR                    khrPresentWait;
     VkPhysicalDeviceRawAccessChainsFeaturesNV                 nvRawAccessChains;
+    VkBool32                                                  nvLowLatency2;
     VkBool32                                                  nvxBinaryImport;
     VkBool32                                                  nvxImageViewHandle;
     VkBool32                                                  khrWin32KeyedMutex;
   };
 
-}
\ No newline at end of file
+}
diff --git a/src/dxvk/dxvk_device_info.h.orig b/src/dxvk/dxvk_device_info.h.orig
new file mode 100644
index 00000000..c1da783a
--- /dev/null
+++ b/src/dxvk/dxvk_device_info.h.orig
@@ -0,0 +1,77 @@
+#pragma once
+
+#include "dxvk_include.h"
+
+namespace dxvk {
+
+  /**
+   * \brief Device info
+   * 
+   * Stores core properties and a bunch of extension-specific
+   * properties, if the respective extensions are available.
+   * Structures for unsupported extensions will be undefined,
+   * so before using them, check whether they are supported.
+   */
+  struct DxvkDeviceInfo {
+    VkPhysicalDeviceProperties2                               core;
+    VkPhysicalDeviceVulkan11Properties                        vk11;
+    VkPhysicalDeviceVulkan12Properties                        vk12;
+    VkPhysicalDeviceVulkan13Properties                        vk13;
+    VkPhysicalDeviceConservativeRasterizationPropertiesEXT    extConservativeRasterization;
+    VkPhysicalDeviceCustomBorderColorPropertiesEXT            extCustomBorderColor;
+    VkPhysicalDeviceExtendedDynamicState3PropertiesEXT        extExtendedDynamicState3;
+    VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT      extGraphicsPipelineLibrary;
+    VkPhysicalDeviceLineRasterizationPropertiesEXT            extLineRasterization;
+    VkPhysicalDeviceRobustness2PropertiesEXT                  extRobustness2;
+    VkPhysicalDeviceTransformFeedbackPropertiesEXT            extTransformFeedback;
+    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT       extVertexAttributeDivisor;
+    VkPhysicalDeviceMaintenance5PropertiesKHR                 khrMaintenance5;
+  };
+
+
+  /**
+   * \brief Device features
+   * 
+   * Stores core features and extension-specific features.
+   * If the respective extensions are not available, the
+   * extended features will be marked as unsupported.
+   */
+  struct DxvkDeviceFeatures {
+    VkPhysicalDeviceFeatures2                                 core;
+    VkPhysicalDeviceVulkan11Features                          vk11;
+    VkPhysicalDeviceVulkan12Features                          vk12;
+    VkPhysicalDeviceVulkan13Features                          vk13;
+    VkBool32                                                  amdShaderFragmentMask;
+    VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT   extAttachmentFeedbackLoopLayout;
+    VkBool32                                                  extConservativeRasterization;
+    VkPhysicalDeviceCustomBorderColorFeaturesEXT              extCustomBorderColor;
+    VkPhysicalDeviceDepthClipEnableFeaturesEXT                extDepthClipEnable;
+    VkPhysicalDeviceDepthBiasControlFeaturesEXT               extDepthBiasControl;
+    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT          extExtendedDynamicState3;
+    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT        extFragmentShaderInterlock;
+    VkBool32                                                  extFullScreenExclusive;
+    VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT        extGraphicsPipelineLibrary;
+    VkBool32                                                  extHdrMetadata;
+    VkPhysicalDeviceLineRasterizationFeaturesEXT              extLineRasterization;
+    VkBool32                                                  extMemoryBudget;
+    VkPhysicalDeviceMemoryPriorityFeaturesEXT                 extMemoryPriority;
+    VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT             extNonSeamlessCubeMap;
+    VkPhysicalDeviceRobustness2FeaturesEXT                    extRobustness2;
+    VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT         extShaderModuleIdentifier;
+    VkBool32                                                  extShaderStencilExport;
+    VkBool32                                                  extSwapchainColorSpace;
+    VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT          extSwapchainMaintenance1;
+    VkPhysicalDeviceTransformFeedbackFeaturesEXT              extTransformFeedback;
+    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT         extVertexAttributeDivisor;
+    VkBool32                                                  khrExternalMemoryWin32;
+    VkBool32                                                  khrExternalSemaphoreWin32;
+    VkPhysicalDeviceMaintenance5FeaturesKHR                   khrMaintenance5;
+    VkPhysicalDevicePresentIdFeaturesKHR                      khrPresentId;
+    VkPhysicalDevicePresentWaitFeaturesKHR                    khrPresentWait;
+    VkPhysicalDeviceRawAccessChainsFeaturesNV                 nvRawAccessChains;
+    VkBool32                                                  nvxBinaryImport;
+    VkBool32                                                  nvxImageViewHandle;
+    VkBool32                                                  khrWin32KeyedMutex;
+  };
+
+}
\ No newline at end of file
diff --git a/src/dxvk/dxvk_device_info.h.rej b/src/dxvk/dxvk_device_info.h.rej
new file mode 100644
index 00000000..fa67b8c8
--- /dev/null
+++ b/src/dxvk/dxvk_device_info.h.rej
@@ -0,0 +1,13 @@
+--- src/dxvk/dxvk_device_info.h
++++ src/dxvk/dxvk_device_info.h
+@@ -68,9 +68,10 @@ namespace dxvk {
+     VkPhysicalDeviceMaintenance5FeaturesKHR                   khrMaintenance5;
+     VkPhysicalDevicePresentIdFeaturesKHR                      khrPresentId;
+     VkPhysicalDevicePresentWaitFeaturesKHR                    khrPresentWait;
++    VkBool32                                                  nvLowLatency2;
+     VkBool32                                                  nvxBinaryImport;
+     VkBool32                                                  nvxImageViewHandle;
+     VkBool32                                                  khrWin32KeyedMutex;
+   };
+ 
+-}+}
diff --git a/src/dxvk/dxvk_extensions.h b/src/dxvk/dxvk_extensions.h
index 63c922cf..21842f43 100644
--- a/src/dxvk/dxvk_extensions.h
+++ b/src/dxvk/dxvk_extensions.h
@@ -325,6 +325,7 @@ namespace dxvk {
     DxvkExt khrPresentWait                    = { VK_KHR_PRESENT_WAIT_EXTENSION_NAME,                       DxvkExtMode::Optional };
     DxvkExt khrSwapchain                      = { VK_KHR_SWAPCHAIN_EXTENSION_NAME,                          DxvkExtMode::Required };
     DxvkExt khrWin32KeyedMutex                = { VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME,                  DxvkExtMode::Optional };
+    DxvkExt nvLowLatency2                     = { VK_NV_LOW_LATENCY_2_EXTENSION_NAME,                       DxvkExtMode::Optional };
     DxvkExt nvRawAccessChains                 = { VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME,                   DxvkExtMode::Optional };
     DxvkExt nvxBinaryImport                   = { VK_NVX_BINARY_IMPORT_EXTENSION_NAME,                      DxvkExtMode::Disabled };
     DxvkExt nvxImageViewHandle                = { VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME,                  DxvkExtMode::Disabled };
diff --git a/src/dxvk/dxvk_extensions.h.orig b/src/dxvk/dxvk_extensions.h.orig
new file mode 100644
index 00000000..63c922cf
--- /dev/null
+++ b/src/dxvk/dxvk_extensions.h.orig
@@ -0,0 +1,346 @@
+#pragma once
+
+#include <algorithm>
+#include <map>
+#include <vector>
+
+#include "dxvk_include.h"
+
+namespace dxvk {
+  
+  /**
+   * \brief Vulkan extension mode
+   * 
+   * Defines whether an extension is
+   * optional, required, or disabled.
+   */
+  enum class DxvkExtMode {
+    Disabled,
+    Optional,
+    Required,
+    Passive,
+  };
+
+
+  /**
+   * \brief Vulkan extension info
+   * 
+   * Stores information for a single extension.
+   * The renderer can use this information to
+   * find out which extensions are enabled.
+   */
+  class DxvkExt {
+
+  public:
+
+    DxvkExt(
+      const char*       pName,
+            DxvkExtMode mode)
+    : m_name(pName), m_mode(mode) { }
+
+    /**
+     * \brief Extension name
+     * \returns Extension name
+     */
+    const char* name() const {
+      return m_name;
+    }
+
+    /**
+     * \brief Extension mode
+     * \returns Extension mode
+     */
+    DxvkExtMode mode() const {
+      return m_mode;
+    }
+
+    /**
+     * \brief Checks whether the extension is enabled
+     * 
+     * If an extension is enabled, the features
+     * provided by the extension can be used.
+     * \returns \c true if the extension is enabled
+     */
+    explicit operator bool () const {
+      return m_revision != 0;
+    }
+
+    /**
+     * \brief Supported revision
+     * \returns Supported revision
+     */
+    uint32_t revision() const {
+      return m_revision;
+    }
+
+    /**
+     * \brief Changes extension mode
+     * 
+     * In some cases, it may be useful to change the
+     * default mode dynamically after initialization.
+     */
+    void setMode(DxvkExtMode mode) {
+      m_mode = mode;
+    }
+
+    /**
+     * \brief Enables the extension
+     */
+    void enable(uint32_t revision) {
+      m_revision = revision;
+    }
+
+    /**
+     * \brief Disables the extension
+     */
+    void disable() {
+      m_revision = 0;
+    }
+
+  private:
+
+    const char* m_name     = nullptr;
+    DxvkExtMode m_mode     = DxvkExtMode::Disabled;
+    uint32_t    m_revision = 0;
+
+  };
+
+
+  /**
+   * \brief Vulkan name list
+   * 
+   * A simple \c vector wrapper that can
+   * be used to build a list of layer and
+   * extension names.
+   */
+  class DxvkNameList {
+
+  public:
+
+    DxvkNameList() { }
+    DxvkNameList(uint32_t count, const char* const* names) {
+      for (uint32_t i = 0; i < count; i++)
+        add(names[i]);
+    }
+
+    /**
+     * \brief Adds a name
+     * \param [in] pName The name
+     */
+    void add(const char* pName) {
+      m_names.push_back(pName);
+    }
+
+    /**
+     * \brief Number of names
+     * \returns Name count
+     */
+    uint32_t count() const {
+      return m_names.size();
+    }
+
+    /**
+     * \brief Name list
+     * \returns Name list
+     */
+    const char* const* names() const {
+      return m_names.data();
+    }
+
+    /**
+     * \brief Retrieves a single name
+     * 
+     * \param [in] index Name index
+     * \returns The given name
+     */
+    const char* name(uint32_t index) const {
+      return m_names.at(index);
+    }
+
+  private:
+
+    std::vector<const char*> m_names;
+
+  };
+
+
+  /**
+   * \brief Vulkan extension set
+   * 
+   * Stores a set of extensions or layers
+   * supported by the Vulkan implementation.
+   */
+  class DxvkNameSet {
+
+  public:
+
+    DxvkNameSet();
+
+    DxvkNameSet(
+            uint32_t          count,
+      const char* const*      names);
+
+    ~DxvkNameSet();
+
+    /**
+     * \brief Adds a name to the set
+     * \param [in] pName Extension name
+     */
+    void add(
+      const char*             pName);
+    
+    /**
+     * \brief Merges two name sets
+     * 
+     * Adds all names from the given name set to
+     * this name set, avoiding duplicate entries.
+     * \param [in] names Name set to merge
+     */
+    void merge(
+      const DxvkNameSet&      names);
+
+    /**
+     * \brief Pulls in revisions from another name set
+     * \param [in] names Name set to pull revisions from
+     */
+    void mergeRevisions(
+      const DxvkNameSet&      names);
+
+    /**
+     * \brief Checks whether an extension is supported
+     * 
+     * \param [in] pName Extension name
+     * \returns Supported revision, or zero
+     */
+    uint32_t supports(
+      const char*             pName) const;
+    
+    /**
+     * \brief Enables requested extensions
+     * 
+     * Walks over a set of extensions and enables all
+     * extensions that are supported and not disabled.
+     * This also checks whether all required extensions
+     * could be enabled, and returns \c false otherwise.
+     * \param [in] numExtensions Number of extensions
+     * \param [in] ppExtensions List of extensions
+     * \param [out] nameSet Extension name set
+     * \returns \c true on success
+     */
+    bool enableExtensions(
+            uint32_t          numExtensions,
+            DxvkExt**         ppExtensions,
+            DxvkNameSet*      nameSet) const;
+    
+    /**
+     * \brief Disables given extension
+     *
+     * Removes the given extension from the set
+     * and sets its revision to 0 (i.e. disabled).
+     * \param [in,out] ext Extension to disable
+     */
+    void disableExtension(
+            DxvkExt&          ext);
+
+    /**
+     * \brief Creates name list from name set
+     * 
+     * Adds all names contained in the name set
+     * to a name list, which can then be passed
+     * to Vulkan functions.
+     * \returns Name list
+     */
+    DxvkNameList toNameList() const;
+
+    /**
+     * \brief Enumerates instance layers
+     * 
+     * \param [in] vkl Vulkan library functions
+     * \returns Set of available instance layers
+     */
+    static DxvkNameSet enumInstanceLayers(
+      const Rc<vk::LibraryFn>&  vkl);
+    
+    /**
+     * \brief Enumerates instance extensions
+     * 
+     * \param [in] vkl Vulkan library functions
+     * \returns Set of available instance extensions
+     */
+    static DxvkNameSet enumInstanceExtensions(
+      const Rc<vk::LibraryFn>&  vkl);
+    
+    /**
+     * \brief Enumerates device extensions
+     * 
+     * \param [in] vki Vulkan instance functions
+     * \param [in] device The device to query
+     * \returns Set of available device extensions
+     */
+    static DxvkNameSet enumDeviceExtensions(
+      const Rc<vk::InstanceFn>& vki,
+            VkPhysicalDevice    device);
+
+  private:
+
+    std::map<std::string, uint32_t> m_names;
+
+  };
+
+  /**
+   * \brief Device extensions
+   * 
+   * Lists all Vulkan extensions that are potentially
+   * used by DXVK if supported by the implementation.
+   */
+  struct DxvkDeviceExtensions {
+    DxvkExt amdMemoryOverallocationBehaviour  = { VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME,     DxvkExtMode::Optional };
+    DxvkExt amdShaderFragmentMask             = { VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME,               DxvkExtMode::Optional };
+    DxvkExt extAttachmentFeedbackLoopLayout   = { VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME,    DxvkExtMode::Optional };
+    DxvkExt extConservativeRasterization      = { VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME,         DxvkExtMode::Optional };
+    DxvkExt extCustomBorderColor              = { VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME,                DxvkExtMode::Optional };
+    DxvkExt extDepthClipEnable                = { VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME,                  DxvkExtMode::Optional };
+    DxvkExt extDepthBiasControl               = { VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME,                 DxvkExtMode::Optional };
+    DxvkExt extExtendedDynamicState3          = { VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME,           DxvkExtMode::Optional };
+    DxvkExt extFullScreenExclusive            = { VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME,              DxvkExtMode::Optional };
+    DxvkExt extFragmentShaderInterlock        = { VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME,          DxvkExtMode::Optional };
+    DxvkExt extGraphicsPipelineLibrary        = { VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME,          DxvkExtMode::Optional };
+    DxvkExt extLineRasterization              = { VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME,                 DxvkExtMode::Passive  };
+    DxvkExt extMemoryBudget                   = { VK_EXT_MEMORY_BUDGET_EXTENSION_NAME,                      DxvkExtMode::Passive  };
+    DxvkExt extMemoryPriority                 = { VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME,                    DxvkExtMode::Optional };
+    DxvkExt extNonSeamlessCubeMap             = { VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME,              DxvkExtMode::Optional };
+    DxvkExt extRobustness2                    = { VK_EXT_ROBUSTNESS_2_EXTENSION_NAME,                       DxvkExtMode::Required };
+    DxvkExt extShaderModuleIdentifier         = { VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME,           DxvkExtMode::Optional };
+    DxvkExt extShaderStencilExport            = { VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME,              DxvkExtMode::Optional };
+    DxvkExt extSwapchainColorSpace            = { VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME,              DxvkExtMode::Optional };
+    DxvkExt extSwapchainMaintenance1          = { VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME,            DxvkExtMode::Optional };
+    DxvkExt extHdrMetadata                    = { VK_EXT_HDR_METADATA_EXTENSION_NAME,                       DxvkExtMode::Optional };
+    DxvkExt extTransformFeedback              = { VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME,                 DxvkExtMode::Optional };
+    DxvkExt extVertexAttributeDivisor         = { VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME,           DxvkExtMode::Optional };
+    DxvkExt khrExternalMemoryWin32            = { VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME,              DxvkExtMode::Optional };
+    DxvkExt khrExternalSemaphoreWin32         = { VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME,           DxvkExtMode::Optional };
+    DxvkExt khrMaintenance5                   = { VK_KHR_MAINTENANCE_5_EXTENSION_NAME,                      DxvkExtMode::Optional };
+    DxvkExt khrPipelineLibrary                = { VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME,                   DxvkExtMode::Optional };
+    DxvkExt khrPresentId                      = { VK_KHR_PRESENT_ID_EXTENSION_NAME,                         DxvkExtMode::Optional };
+    DxvkExt khrPresentWait                    = { VK_KHR_PRESENT_WAIT_EXTENSION_NAME,                       DxvkExtMode::Optional };
+    DxvkExt khrSwapchain                      = { VK_KHR_SWAPCHAIN_EXTENSION_NAME,                          DxvkExtMode::Required };
+    DxvkExt khrWin32KeyedMutex                = { VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME,                  DxvkExtMode::Optional };
+    DxvkExt nvRawAccessChains                 = { VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME,                   DxvkExtMode::Optional };
+    DxvkExt nvxBinaryImport                   = { VK_NVX_BINARY_IMPORT_EXTENSION_NAME,                      DxvkExtMode::Disabled };
+    DxvkExt nvxImageViewHandle                = { VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME,                  DxvkExtMode::Disabled };
+  };
+  
+  /**
+   * \brief Instance extensions
+   * 
+   * Lists all Vulkan extensions that are potentially
+   * used by DXVK if supported by the implementation.
+   */
+  struct DxvkInstanceExtensions {
+    DxvkExt extDebugUtils                   = { VK_EXT_DEBUG_UTILS_EXTENSION_NAME,                      DxvkExtMode::Optional };
+    DxvkExt extSurfaceMaintenance1          = { VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME,            DxvkExtMode::Optional };
+    DxvkExt khrGetSurfaceCapabilities2      = { VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME,       DxvkExtMode::Optional };
+    DxvkExt khrSurface                      = { VK_KHR_SURFACE_EXTENSION_NAME,                          DxvkExtMode::Required };
+  };
+  
+}
diff --git a/src/dxvk/dxvk_extensions.h.rej b/src/dxvk/dxvk_extensions.h.rej
new file mode 100644
index 00000000..dc50b6c1
--- /dev/null
+++ b/src/dxvk/dxvk_extensions.h.rej
@@ -0,0 +1,10 @@
+--- src/dxvk/dxvk_extensions.h
++++ src/dxvk/dxvk_extensions.h
+@@ -325,6 +325,7 @@ namespace dxvk {
+     DxvkExt khrPresentWait                    = { VK_KHR_PRESENT_WAIT_EXTENSION_NAME,                       DxvkExtMode::Optional };
+     DxvkExt khrSwapchain                      = { VK_KHR_SWAPCHAIN_EXTENSION_NAME,                          DxvkExtMode::Required };
+     DxvkExt khrWin32KeyedMutex                = { VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME,                  DxvkExtMode::Optional };
++    DxvkExt nvLowLatency2                     = { VK_NV_LOW_LATENCY_2_EXTENSION_NAME,                       DxvkExtMode::Optional };
+     DxvkExt nvxBinaryImport                   = { VK_NVX_BINARY_IMPORT_EXTENSION_NAME,                      DxvkExtMode::Disabled };
+     DxvkExt nvxImageViewHandle                = { VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME,                  DxvkExtMode::Disabled };
+   };
diff --git a/src/dxvk/dxvk_presenter.cpp b/src/dxvk/dxvk_presenter.cpp
index 10f13da2..b89eddef 100644
--- a/src/dxvk/dxvk_presenter.cpp
+++ b/src/dxvk/dxvk_presenter.cpp
@@ -18,6 +18,15 @@ namespace dxvk {
     // with present operations and periodically signals the event
     if (m_device->features().khrPresentWait.presentWait && m_signal != nullptr)
       m_frameThread = dxvk::thread([this] { runFrameThread(); });
+
+    // If nvLowLatency2 is supported create the fence
+    if (m_device->features().nvLowLatency2) {
+      DxvkFenceCreateInfo info = {};
+      info.initialValue = 0;
+      info.sharedType   = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM;
+
+      m_lowLatencyFence = DxvkFenceValuePair(m_device->createFence(info), 0u);
+    }
   }
 
   
@@ -72,7 +81,7 @@ namespace dxvk {
 
     VkPresentIdKHR presentId = { VK_STRUCTURE_TYPE_PRESENT_ID_KHR };
     presentId.swapchainCount = 1;
-    presentId.pPresentIds   = &frameId;
+    presentId.pPresentIds    = &frameId;
 
     VkSwapchainPresentModeInfoEXT modeInfo = { VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT };
     modeInfo.swapchainCount = 1;
@@ -88,8 +97,11 @@ namespace dxvk {
     if (m_device->features().khrPresentId.presentId && frameId)
       presentId.pNext = const_cast<void*>(std::exchange(info.pNext, &presentId));
 
-    if (m_device->features().extSwapchainMaintenance1.swapchainMaintenance1)
+    if (m_device->features().extSwapchainMaintenance1.swapchainMaintenance1) {
+      if (m_device->features().nvLowLatency2)
+        m_presentSupportsLowLatency = std::find(m_lowLatencyModes.begin(), m_lowLatencyModes.end(), mode) != m_lowLatencyModes.end();
       modeInfo.pNext = const_cast<void*>(std::exchange(info.pNext, &modeInfo));
+    }
 
     VkResult status = m_vkd->vkQueuePresentKHR(
       m_device->queues().graphics.queueHandle, &info);
@@ -173,6 +185,7 @@ namespace dxvk {
 
     std::vector<VkSurfaceFormatKHR> formats;
     std::vector<VkPresentModeKHR> modes;
+    std::vector<VkPresentModeKHR> lowLatencyModes;
 
     VkResult status;
 
@@ -283,6 +296,23 @@ namespace dxvk {
       dynamicModes.clear();
     }
 
+    if (m_device->features().nvLowLatency2) {
+      VkLatencySurfaceCapabilitiesNV latencySurfaceCaps { VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV };
+
+      caps.pNext = &latencySurfaceCaps;
+
+      if((status = m_vki->vkGetPhysicalDeviceSurfaceCapabilities2KHR(m_device->adapter()->handle(), &surfaceInfo, &caps)))
+        return status;
+
+      lowLatencyModes.resize(latencySurfaceCaps.presentModeCount);
+      latencySurfaceCaps.pPresentModes = lowLatencyModes.data();
+
+      if ((status = m_vki->vkGetPhysicalDeviceSurfaceCapabilities2KHR(m_device->adapter()->handle(), &surfaceInfo, &caps)))
+        return status;
+
+      caps.pNext = nullptr;
+    }
+
     // Compute swap chain image count based on available info
     m_info.imageCount = pickImageCount(minImageCount, maxImageCount, desc.imageCount);
 
@@ -293,6 +323,9 @@ namespace dxvk {
     modeInfo.presentModeCount       = compatibleModes.size();
     modeInfo.pPresentModes          = compatibleModes.data();
 
+    VkSwapchainLatencyCreateInfoNV lowLatencyInfo = { VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV };
+    lowLatencyInfo.latencyModeEnable = VK_TRUE;
+
     VkSwapchainCreateInfoKHR swapInfo = { VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR };
     swapInfo.surface                = m_surface;
     swapInfo.minImageCount          = m_info.imageCount;
@@ -314,6 +347,9 @@ namespace dxvk {
     if (m_device->features().extSwapchainMaintenance1.swapchainMaintenance1)
       modeInfo.pNext = std::exchange(swapInfo.pNext, &modeInfo);
 
+    if (m_device->features().nvLowLatency2)
+      lowLatencyInfo.pNext = std::exchange(swapInfo.pNext, &lowLatencyInfo);
+
     Logger::info(str::format(
       "Presenter: Actual swap chain properties:"
       "\n  Format:       ", m_info.format.format,
@@ -322,11 +358,29 @@ namespace dxvk {
       "\n  Buffer size:  ", m_info.imageExtent.width, "x", m_info.imageExtent.height,
       "\n  Image count:  ", m_info.imageCount,
       "\n  Exclusive FS: ", desc.fullScreenExclusive));
-    
+
     if ((status = m_vkd->vkCreateSwapchainKHR(m_vkd->device(),
         &swapInfo, nullptr, &m_swapchain)))
       return status;
-    
+
+    if (m_device->features().nvLowLatency2) {
+      std::lock_guard<dxvk::mutex> lock(m_lowLatencyMutex);
+
+      if (!m_lowLatencyEnabled)
+        m_device->resetLatencyMarkers();
+
+      VkLatencySleepModeInfoNV sleepModeInfo = { VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV };
+      sleepModeInfo.lowLatencyMode  = m_lowLatencyEnabled;
+      sleepModeInfo.lowLatencyBoost = m_lowLatencyBoost;
+      sleepModeInfo.minimumIntervalUs = m_minimumIntervalUs;
+
+      if ((status = m_vkd->vkSetLatencySleepModeNV(m_vkd->device(), m_swapchain, &sleepModeInfo)))
+        return status;
+
+      m_presentSupportsLowLatency = std::find(
+        lowLatencyModes.begin(), lowLatencyModes.end(), m_info.presentMode) != lowLatencyModes.end();
+    }
+
     // Acquire images and create views
     std::vector<VkImage> images;
 
@@ -377,6 +431,7 @@ namespace dxvk {
     m_acquireStatus = VK_NOT_READY;
 
     m_dynamicModes = std::move(dynamicModes);
+    m_lowLatencyModes = std::move(lowLatencyModes);
     return VK_SUCCESS;
   }
 
@@ -423,6 +478,73 @@ namespace dxvk {
   }
 
 
+  void Presenter::setLatencySleepMode(bool lowLatencyMode, bool lowLatencyBoost, uint32_t minimumIntervalUs) {
+    if (lowLatencyMode == m_lowLatencyEnabled
+     && lowLatencyBoost == m_lowLatencyBoost
+     && minimumIntervalUs == m_minimumIntervalUs) {
+      return;
+    }
+
+    std::lock_guard<dxvk::mutex> lock(m_lowLatencyMutex);
+
+    m_lowLatencyEnabled = lowLatencyMode;
+    m_lowLatencyBoost = lowLatencyBoost;
+    m_minimumIntervalUs = minimumIntervalUs;
+  }
+
+
+  void Presenter::latencySleep() {
+    VkSemaphore sem = m_lowLatencyFence.fence->handle();
+    uint64_t waitValue = m_lowLatencyFence.value + 1;
+    m_lowLatencyFence.value++;
+
+    VkLatencySleepInfoNV sleepInfo = { VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV };
+    sleepInfo.signalSemaphore = sem;
+    sleepInfo.value = waitValue;
+
+    bool shouldSleep = false;
+
+    {
+      std::lock_guard<dxvk::mutex> lock(m_lowLatencyMutex);
+      if (m_swapchain) {
+        shouldSleep = true;
+        m_vkd->vkLatencySleepNV(m_vkd->device(), m_swapchain, &sleepInfo);
+      }
+    }
+
+    if (shouldSleep)
+      m_lowLatencyFence.fence->wait(waitValue);
+  }
+
+
+  void Presenter::setLatencyMarker(VkLatencyMarkerNV marker, uint64_t presentId) {
+    VkSetLatencyMarkerInfoNV markerInfo = { VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV };
+    markerInfo.presentID = presentId;
+    markerInfo.marker = marker;
+
+    std::lock_guard<dxvk::mutex> lock(m_lowLatencyMutex);
+    if (m_swapchain)
+      m_vkd->vkSetLatencyMarkerNV(m_vkd->device(), m_swapchain, &markerInfo);
+  }
+
+
+  void Presenter::getLatencyTimings(std::vector<VkLatencyTimingsFrameReportNV>& frameReports) {
+    std::lock_guard<dxvk::mutex> lock(m_lowLatencyMutex);
+    
+    if (m_swapchain) {
+      VkGetLatencyMarkerInfoNV markerInfo = { VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV };
+      m_vkd->vkGetLatencyTimingsNV(m_vkd->device(), m_swapchain, &markerInfo);
+
+      if (markerInfo.timingCount != 0) {
+        frameReports.resize(markerInfo.timingCount, { VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV });
+        markerInfo.pTimings = frameReports.data();
+
+        m_vkd->vkGetLatencyTimingsNV(m_vkd->device(), m_swapchain, &markerInfo);
+      }
+    }
+  }
+
+
   VkResult Presenter::getSupportedFormats(std::vector<VkSurfaceFormatKHR>& formats, VkFullScreenExclusiveEXT fullScreenExclusive) const {
     uint32_t numFormats = 0;
 
@@ -617,6 +739,8 @@ namespace dxvk {
 
 
   void Presenter::destroySwapchain() {
+    std::lock_guard<dxvk::mutex> lock(m_lowLatencyMutex);
+
     if (m_signal != nullptr)
       m_signal->wait(m_lastFrameId.load(std::memory_order_acquire));
 
diff --git a/src/dxvk/dxvk_presenter.h b/src/dxvk/dxvk_presenter.h
index c5ba1273..6918d18a 100644
--- a/src/dxvk/dxvk_presenter.h
+++ b/src/dxvk/dxvk_presenter.h
@@ -15,6 +15,7 @@
 #include "../vulkan/vulkan_loader.h"
 
 #include "dxvk_format.h"
+#include "dxvk_fence.h"
 
 namespace dxvk {
 
@@ -224,6 +225,42 @@ namespace dxvk {
      */
     void setHdrMetadata(const VkHdrMetadataEXT& hdrMetadata);
 
+    /**
+     * \brief Set the latency mode of the swapchain
+     *
+     * \param [in] enableLowLatency Determines if the low latency
+     * mode should be enabled of disabled
+     */
+    void setLatencySleepMode(bool lowLatencyMode, bool lowLatencyBoost, uint32_t minimumIntervalUs);
+
+    /**
+     * \brief Delay rendering work for lower latency
+     */
+    void latencySleep();
+
+    /**
+     * \brief Set a latency marker for the given stage
+     *
+     * \param [in] marker The stage this marker is for
+     * \param [in] presentId The presentId this marker is for
+     */
+    void setLatencyMarker(VkLatencyMarkerNV marker, uint64_t presentId);
+
+    /**
+     * \brief Get the low latency timing info
+     *
+     * \param [out] latencyInfo The structure to place
+     * the latency timings into
+     */
+    void getLatencyTimings(std::vector<VkLatencyTimingsFrameReportNV>& frameReports);
+
+    /**
+     * \brief Returns the low latency enabled state
+     */
+    bool lowLatencyEnabled() {
+      return m_lowLatencyEnabled && m_presentSupportsLowLatency;
+    }
+
   private:
 
     Rc<DxvkDevice>    m_device;
@@ -237,10 +274,17 @@ namespace dxvk {
     VkSurfaceKHR      m_surface     = VK_NULL_HANDLE;
     VkSwapchainKHR    m_swapchain   = VK_NULL_HANDLE;
 
+    DxvkFenceValuePair m_lowLatencyFence   = {};
+    bool               m_lowLatencyEnabled = false;
+    bool               m_lowLatencyBoost   = false; 
+    uint32_t           m_minimumIntervalUs = 0;
+    bool               m_presentSupportsLowLatency = false;
+
     std::vector<PresenterImage> m_images;
     std::vector<PresenterSync>  m_semaphores;
 
     std::vector<VkPresentModeKHR> m_dynamicModes;
+    std::vector<VkPresentModeKHR> m_lowLatencyModes;
 
     uint32_t          m_imageIndex = 0;
     uint32_t          m_frameIndex = 0;
@@ -250,6 +294,7 @@ namespace dxvk {
     FpsLimiter        m_fpsLimiter;
 
     dxvk::mutex                 m_frameMutex;
+    dxvk::mutex                 m_lowLatencyMutex;
     dxvk::condition_variable    m_frameCond;
     dxvk::thread                m_frameThread;
     std::queue<PresenterFrame>  m_frameQueue;
diff --git a/src/dxvk/dxvk_queue.cpp b/src/dxvk/dxvk_queue.cpp
index 7273a37d..546a1f83 100644
--- a/src/dxvk/dxvk_queue.cpp
+++ b/src/dxvk/dxvk_queue.cpp
@@ -126,7 +126,7 @@ namespace dxvk {
           m_callback(true);
 
         if (entry.submit.cmdList != nullptr)
-          entry.result = entry.submit.cmdList->submit();
+          entry.result = entry.submit.cmdList->submit(entry.submit.frameId);
         else if (entry.present.presenter != nullptr)
           entry.result = entry.present.presenter->presentImage(entry.present.presentMode, entry.present.frameId);
 
@@ -226,4 +226,4 @@ namespace dxvk {
     }
   }
   
-}
\ No newline at end of file
+}
diff --git a/src/dxvk/dxvk_queue.h b/src/dxvk/dxvk_queue.h
index 38d91f5d..a3c6e581 100644
--- a/src/dxvk/dxvk_queue.h
+++ b/src/dxvk/dxvk_queue.h
@@ -32,6 +32,7 @@ namespace dxvk {
    */
   struct DxvkSubmitInfo {
     Rc<DxvkCommandList> cmdList;
+    uint64_t frameId;
   };
   
   
diff --git a/src/vulkan/vulkan_loader.h b/src/vulkan/vulkan_loader.h
index 1741ccb8..6b0f80ea 100644
--- a/src/vulkan/vulkan_loader.h
+++ b/src/vulkan/vulkan_loader.h
@@ -452,6 +452,14 @@ namespace dxvk::vk {
     VULKAN_FN(wine_vkAcquireKeyedMutex);
     VULKAN_FN(wine_vkReleaseKeyedMutex);
     #endif
+
+    #ifdef VK_NV_LOW_LATENCY_2_EXTENSION_NAME
+    VULKAN_FN(vkSetLatencySleepModeNV);
+    VULKAN_FN(vkLatencySleepNV);
+    VULKAN_FN(vkSetLatencyMarkerNV);
+    VULKAN_FN(vkGetLatencyTimingsNV);
+    VULKAN_FN(vkQueueNotifyOutOfBandNV);
+    #endif
   };
   
 }
-- 
2.44.0

