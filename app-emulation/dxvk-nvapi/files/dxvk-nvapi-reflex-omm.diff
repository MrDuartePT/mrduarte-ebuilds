diff --git a/src/d3d12/nvapi_d3d12_device.cpp b/src/d3d12/nvapi_d3d12_device.cpp
index 0d30d34..4ebe918 100644
--- a/src/d3d12/nvapi_d3d12_device.cpp
+++ b/src/d3d12/nvapi_d3d12_device.cpp
@@ -120,6 +120,91 @@ namespace dxvk {
         return cubinDevice != nullptr;
     }
 
+    bool NvapiD3d12Device::AreOpacityMicromapsSupported(ID3D12Device* device) {
+        auto ommDevice = GetOmmDevice(device);
+        return ommDevice != nullptr;
+    }
+
+    std::optional<NvAPI_Status> NvapiD3d12Device::SetCreatePipelineStateOptions(ID3D12Device5* device, const NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS* params) {
+        auto ommDevice = GetOmmDevice(device);
+        if (ommDevice == nullptr)
+            return std::nullopt;
+
+        return static_cast<NvAPI_Status>(ommDevice->SetCreatePipelineStateOptions(params));
+    }
+
+    std::optional<NvAPI_Status> NvapiD3d12Device::CheckDriverMatchingIdentifierEx(ID3D12Device5* device, NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS* params) {
+        auto ommDevice = GetOmmDevice(device);
+        if (ommDevice == nullptr)
+            return std::nullopt;
+
+        return static_cast<NvAPI_Status>(ommDevice->CheckDriverMatchingIdentifierEx(params));
+    }
+
+    std::optional<NvAPI_Status> NvapiD3d12Device::GetRaytracingAccelerationStructurePrebuildInfoEx(ID3D12Device5* device, NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS* params) {
+        auto ommDevice = GetOmmDevice(device);
+        if (ommDevice == nullptr)
+            return std::nullopt;
+
+        return static_cast<NvAPI_Status>(ommDevice->GetRaytracingAccelerationStructurePrebuildInfoEx(params));
+    }
+
+    std::optional<NvAPI_Status> NvapiD3d12Device::GetRaytracingOpacityMicromapArrayPrebuildInfo(ID3D12Device5* device, NVAPI_GET_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO_PARAMS* params) {
+        auto ommDevice = GetOmmDevice(device);
+        if (ommDevice == nullptr)
+            return std::nullopt;
+
+        return static_cast<NvAPI_Status>(ommDevice->GetRaytracingOpacityMicromapArrayPrebuildInfo(params));
+    }
+
+    std::optional<NvAPI_Status> NvapiD3d12Device::BuildRaytracingAccelerationStructureEx(ID3D12GraphicsCommandList4* commandList, const NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS* params) {
+        auto commandListExt = GetCommandListExt(commandList);
+        if (!commandListExt.has_value())
+            return std::nullopt;
+
+        auto commandListVer = commandListExt.value();
+        if (commandListVer.InterfaceVersion < 2)
+            return std::nullopt;
+
+        return static_cast<NvAPI_Status>(commandListVer.CommandListExt->BuildRaytracingAccelerationStructureEx(params));
+    }
+
+    std::optional<NvAPI_Status> NvapiD3d12Device::BuildRaytracingOpacityMicromapArray(ID3D12GraphicsCommandList4* commandList, NVAPI_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS* params) {
+        auto commandListExt = GetCommandListExt(commandList);
+        if (!commandListExt.has_value())
+            return std::nullopt;
+
+        auto commandListVer = commandListExt.value();
+        if (commandListVer.InterfaceVersion < 2)
+            return std::nullopt;
+
+        return static_cast<NvAPI_Status>(commandListVer.CommandListExt->BuildRaytracingOpacityMicromapArray(params));
+    }
+
+    std::optional<NvAPI_Status> NvapiD3d12Device::RelocateRaytracingOpacityMicromapArray(ID3D12GraphicsCommandList4* commandList, const NVAPI_RELOCATE_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS* params) {
+        auto commandListExt = GetCommandListExt(commandList);
+        if (!commandListExt.has_value())
+            return std::nullopt;
+
+        auto commandListVer = commandListExt.value();
+        if (commandListVer.InterfaceVersion < 2)
+            return std::nullopt;
+
+        return static_cast<NvAPI_Status>(commandListVer.CommandListExt->RelocateRaytracingOpacityMicromapArray(params));
+    }
+
+    std::optional<NvAPI_Status> NvapiD3d12Device::EmitRaytracingOpacityMicromapArrayPostbuildInfo(ID3D12GraphicsCommandList4* commandList, const NVAPI_EMIT_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_PARAMS* params) {
+        auto commandListExt = GetCommandListExt(commandList);
+        if (!commandListExt.has_value())
+            return std::nullopt;
+
+        auto commandListVer = commandListExt.value();
+        if (commandListVer.InterfaceVersion < 2)
+            return std::nullopt;
+
+        return static_cast<NvAPI_Status>(commandListVer.CommandListExt->EmitRaytracingOpacityMicromapArrayPostbuildInfo(params));
+    }
+
     // We are going to have single map for storing devices with extensions D3D12_VK_NVX_BINARY_IMPORT & D3D12_VK_NVX_IMAGE_VIEW_HANDLE.
     // These are specific to NVIDIA and both of these extensions goes together.
     Com<ID3D12DeviceExt> NvapiD3d12Device::GetCubinDevice(ID3D12Device* device) {
@@ -128,15 +213,29 @@ namespace dxvk {
         if (it != m_cubinDeviceMap.end())
             return it->second;
 
-        auto cubinDevice = GetDeviceExt(device, D3D12_VK_NVX_BINARY_IMPORT);
+        auto cubinDevice = GetDeviceExt<ID3D12DeviceExt>(device, D3D12_VK_NVX_BINARY_IMPORT);
         if (cubinDevice != nullptr)
             m_cubinDeviceMap.emplace(device, cubinDevice.ptr());
 
         return cubinDevice;
     }
 
-    Com<ID3D12DeviceExt> NvapiD3d12Device::GetDeviceExt(ID3D12Device* device, D3D12_VK_EXTENSION extension) {
-        Com<ID3D12DeviceExt> deviceExt;
+    Com<ID3D12DeviceExt1> NvapiD3d12Device::GetOmmDevice(ID3D12Device* device) {
+        std::scoped_lock lock(m_ommDeviceMutex);
+        auto it = m_ommDeviceMap.find(device);
+        if (it != m_ommDeviceMap.end())
+            return it->second;
+
+        auto ommDevice = GetDeviceExt<ID3D12DeviceExt1>(device, D3D12_VK_EXT_OPACITY_MICROMAP);
+        if (ommDevice != nullptr)
+            m_ommDeviceMap.emplace(device, ommDevice.ptr());
+
+        return ommDevice;
+    }
+
+    template <typename T>
+    Com<T> NvapiD3d12Device::GetDeviceExt(ID3D12Device* device, D3D12_VK_EXTENSION extension) {
+        Com<T> deviceExt;
         if (FAILED(device->QueryInterface(IID_PPV_ARGS(&deviceExt))))
             return nullptr;
 
@@ -152,15 +251,21 @@ namespace dxvk {
         if (it != m_commandListMap.end())
             return it->second;
 
+        Com<ID3D12GraphicsCommandListExt2> commandListExt2 = nullptr;
+        if (SUCCEEDED(commandList->QueryInterface(IID_PPV_ARGS(&commandListExt2)))) {
+            NvapiD3d12Device::CommandListExtWithVersion cmdListVer{commandListExt2.ptr(), 2};
+            return std::make_optional(m_commandListMap.emplace(commandList, cmdListVer).first->second);
+        }
+
         Com<ID3D12GraphicsCommandListExt1> commandListExt1 = nullptr;
         if (SUCCEEDED(commandList->QueryInterface(IID_PPV_ARGS(&commandListExt1)))) {
-            NvapiD3d12Device::CommandListExtWithVersion cmdListVer{commandListExt1.ptr(), 1};
+            NvapiD3d12Device::CommandListExtWithVersion cmdListVer{reinterpret_cast<ID3D12GraphicsCommandListExt2*>(commandListExt1.ptr()), 1};
             return std::make_optional(m_commandListMap.emplace(commandList, cmdListVer).first->second);
         }
 
         Com<ID3D12GraphicsCommandListExt> commandListExt = nullptr;
         if (SUCCEEDED(commandList->QueryInterface(IID_PPV_ARGS(&commandListExt)))) {
-            NvapiD3d12Device::CommandListExtWithVersion cmdListVer{reinterpret_cast<ID3D12GraphicsCommandListExt1*>(commandListExt.ptr()), 0};
+            NvapiD3d12Device::CommandListExtWithVersion cmdListVer{reinterpret_cast<ID3D12GraphicsCommandListExt2*>(commandListExt.ptr()), 0};
             return std::make_optional(m_commandListMap.emplace(commandList, cmdListVer).first->second);
         }
 
diff --git a/src/d3d12/nvapi_d3d12_device.h b/src/d3d12/nvapi_d3d12_device.h
index ef419d3..8ebe527 100644
--- a/src/d3d12/nvapi_d3d12_device.h
+++ b/src/d3d12/nvapi_d3d12_device.h
@@ -9,7 +9,7 @@ namespace dxvk {
     class NvapiD3d12Device {
 
         struct CommandListExtWithVersion {
-            ID3D12GraphicsCommandListExt1* CommandListExt;
+            ID3D12GraphicsCommandListExt2* CommandListExt;
             uint32_t InterfaceVersion;
         };
 
@@ -28,22 +28,37 @@ namespace dxvk {
         static bool CaptureUAVInfo(ID3D12Device* device, NVAPI_UAV_INFO* uavInfo);
         static bool IsFatbinPTXSupported(ID3D12Device* device);
 
+        static bool AreOpacityMicromapsSupported(ID3D12Device* device);
+        static std::optional<NvAPI_Status> SetCreatePipelineStateOptions(ID3D12Device5* device, const NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS* params);
+        static std::optional<NvAPI_Status> CheckDriverMatchingIdentifierEx(ID3D12Device5* device, NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS* params);
+        static std::optional<NvAPI_Status> GetRaytracingAccelerationStructurePrebuildInfoEx(ID3D12Device5* device, NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS* params);
+        static std::optional<NvAPI_Status> GetRaytracingOpacityMicromapArrayPrebuildInfo(ID3D12Device5* device, NVAPI_GET_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO_PARAMS* params);
+        static std::optional<NvAPI_Status> BuildRaytracingAccelerationStructureEx(ID3D12GraphicsCommandList4* commandList, const NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS* params);
+        static std::optional<NvAPI_Status> BuildRaytracingOpacityMicromapArray(ID3D12GraphicsCommandList4* commandList, NVAPI_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS* params);
+        static std::optional<NvAPI_Status> RelocateRaytracingOpacityMicromapArray(ID3D12GraphicsCommandList4* commandList, const NVAPI_RELOCATE_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS* params);
+        static std::optional<NvAPI_Status> EmitRaytracingOpacityMicromapArrayPostbuildInfo(ID3D12GraphicsCommandList4* commandList, const NVAPI_EMIT_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_PARAMS* params);
+
         static void ClearCacheMaps();
 
       private:
+        inline static std::unordered_map<ID3D12Device*, ID3D12DeviceExt1*> m_ommDeviceMap;
         inline static std::unordered_map<ID3D12Device*, ID3D12DeviceExt*> m_cubinDeviceMap;
         inline static std::unordered_map<ID3D12CommandQueue*, ID3D12CommandQueueExt*> m_commandQueueMap;
         inline static std::unordered_map<ID3D12GraphicsCommandList*, CommandListExtWithVersion> m_commandListMap;
         inline static std::unordered_map<NVDX_ObjectHandle, NvU32> m_cubinSmemMap;
 
         inline static std::mutex m_commandListMutex;
         inline static std::mutex m_commandQueueMutex;
+        inline static std::mutex m_ommDeviceMutex;
         inline static std::mutex m_cubinDeviceMutex;
         inline static std::mutex m_cubinSmemMutex;
 
+        [[nodiscard]] static Com<ID3D12DeviceExt1> GetOmmDevice(ID3D12Device* device);
         [[nodiscard]] static Com<ID3D12DeviceExt> GetCubinDevice(ID3D12Device* device);
-        [[nodiscard]] static Com<ID3D12DeviceExt> GetDeviceExt(ID3D12Device* device, D3D12_VK_EXTENSION extension);
         [[nodiscard]] static Com<ID3D12CommandQueueExt> GetCommandQueueExt(ID3D12CommandQueue* commandQueue);
         [[nodiscard]] static std::optional<CommandListExtWithVersion> GetCommandListExt(ID3D12GraphicsCommandList* commandList);
+
+        template <typename T>
+        [[nodiscard]] static Com<T> GetDeviceExt(ID3D12Device* device, D3D12_VK_EXTENSION extension);
     };
 }
diff --git a/src/nvapi_d3d12.cpp b/src/nvapi_d3d12.cpp
index aadd7f2..9f70133 100644
--- a/src/nvapi_d3d12.cpp
+++ b/src/nvapi_d3d12.cpp
@@ -270,12 +270,16 @@ extern "C" {
                 *(NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAPS*)pData = NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAP_NONE;
                 break;
 
-            case NVAPI_D3D12_RAYTRACING_CAPS_TYPE_OPACITY_MICROMAP:
+            case NVAPI_D3D12_RAYTRACING_CAPS_TYPE_OPACITY_MICROMAP: {
                 if (dataSize != sizeof(NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS))
                     return InvalidArgument(n);
 
-                *(NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS*)pData = NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_NONE;
+                *(NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS*)pData = NvapiD3d12Device::AreOpacityMicromapsSupported(pDevice)
+                    ? NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_STANDARD
+                    : NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_NONE;
+
                 break;
+            }
 
             case NVAPI_D3D12_RAYTRACING_CAPS_TYPE_DISPLACEMENT_MICROMAP:
                 if (dataSize != sizeof(NVAPI_D3D12_RAYTRACING_DISPLACEMENT_MICROMAP_CAPS))
@@ -291,10 +295,86 @@ extern "C" {
         return Ok(str::format(n, " (", type, ")"));
     }
 
+    NvAPI_Status __cdecl NvAPI_D3D12_GetRaytracingOpacityMicromapArrayPrebuildInfo(ID3D12Device5* pDevice, NVAPI_GET_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO_PARAMS* pParams) {
+        constexpr auto n = __func__;
+        static bool alreadyLoggedOk = false;
+
+        if (pDevice == nullptr || pParams == nullptr)
+            return InvalidArgument(n);
+
+        if (auto result = NvapiD3d12Device::GetRaytracingOpacityMicromapArrayPrebuildInfo(pDevice, pParams); result.has_value()) {
+            auto value = result.value();
+            if (value == NVAPI_OK) {
+                return Ok(n, alreadyLoggedOk);
+            } else {
+                log::write(str::format(n, ": ", value));
+                return value;
+            }
+        }
+
+        return NotSupported(n);
+    }
+
+    NvAPI_Status __cdecl NvAPI_D3D12_SetCreatePipelineStateOptions(ID3D12Device5* pDevice, const NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS* pState) {
+        constexpr auto n = __func__;
+        static bool alreadyLoggedOk = false;
+
+        if (pDevice == nullptr || pState == nullptr)
+            return InvalidArgument(n);
+
+        if (pState->version != NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS_VER1)
+            return IncompatibleStructVersion(n);
+
+        if (auto result = NvapiD3d12Device::SetCreatePipelineStateOptions(pDevice, pState); result.has_value()) {
+            auto value = result.value();
+            if (value == NVAPI_OK) {
+                return Ok(str::format(n, "(", pState->flags, ")"), alreadyLoggedOk);
+            } else {
+                log::write(str::format(n, "(", pState->flags, "): ", value));
+                return value;
+            }
+        }
+
+        return NotSupported(str::format(n, "(", pState->flags, ")"));
+    }
+
+    NvAPI_Status __cdecl NvAPI_D3D12_CheckDriverMatchingIdentifierEx(ID3D12Device5* pDevice, NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS* pParams) {
+        constexpr auto n = __func__;
+        static bool alreadyLoggedOk = false;
+
+        if (pDevice == nullptr || pParams == nullptr)
+            return InvalidArgument(n);
+
+        if (auto result = NvapiD3d12Device::CheckDriverMatchingIdentifierEx(pDevice, pParams); result.has_value()) {
+            auto value = result.value();
+            if (value == NVAPI_OK) {
+                return Ok(n, alreadyLoggedOk);
+            } else {
+                log::write(str::format(n, ": ", value));
+                return value;
+            }
+        }
+
+        if (pParams->version != NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS_VER1)
+            return IncompatibleStructVersion(n);
+
+        if (pParams->serializedDataType == NVAPI_D3D12_SERIALIZED_DATA_RAYTRACING_ACCELERATION_STRUCTURE_EX) {
+            pParams->checkStatus = pDevice->CheckDriverMatchingIdentifier(D3D12_SERIALIZED_DATA_RAYTRACING_ACCELERATION_STRUCTURE, pParams->pIdentifierToCheck);
+            return Ok(n, alreadyLoggedOk);
+        }
+
+        return NotSupported(n);
+    }
+
     static bool ConvertBuildRaytracingAccelerationStructureInputs(const NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_EX* nvDesc, std::vector<D3D12_RAYTRACING_GEOMETRY_DESC>& geometryDescs, D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS* d3dDesc) {
+        // assume that micromaps are not supported, allow only standard stuff to be passed
+        if ((nvDesc->flags & ~0x3f) != 0) {
+            log::write("Nonstandard flags passed to acceleration structure build");
+            return false;
+        }
+
         d3dDesc->Type = nvDesc->type;
-        // assume that OMM via VK_EXT_opacity_micromap and DMM via VK_NV_displacement_micromap are not supported, allow only standard flags to be passed
-        d3dDesc->Flags = static_cast<D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS>(nvDesc->flags & 0x3f);
+        d3dDesc->Flags = static_cast<D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS>(nvDesc->flags);
         d3dDesc->NumDescs = nvDesc->numDescs;
         d3dDesc->DescsLayout = nvDesc->descsLayout;
 
@@ -304,6 +384,13 @@ extern "C" {
         }
 
         if (d3dDesc->Type == D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL && d3dDesc->DescsLayout == D3D12_ELEMENTS_LAYOUT_ARRAY_OF_POINTERS) {
+            for (unsigned i = 0; i < nvDesc->numDescs; ++i) {
+                if (auto desc = nvDesc->ppGeometryDescs[i]; desc->type != NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES_EX && desc->type != NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_PROCEDURAL_PRIMITIVE_AABBS_EX) {
+                    log::write("Triangles with micromap attachment passed to acceleration structure build when micromaps are not supported");
+                    return false;
+                }
+            }
+
             d3dDesc->ppGeometryDescs = reinterpret_cast<const D3D12_RAYTRACING_GEOMETRY_DESC* const*>(nvDesc->ppGeometryDescs);
             return true;
         }
@@ -326,10 +413,10 @@ extern "C" {
                         d3dGeoDesc.Type = D3D12_RAYTRACING_GEOMETRY_TYPE_PROCEDURAL_PRIMITIVE_AABBS;
                         d3dGeoDesc.AABBs = nvGeoDesc.aabbs;
                         break;
-                    case NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_OMM_TRIANGLES_EX: // GetRaytracingCaps reports no OMM caps, we shouldn't reach this
+                    case NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_OMM_TRIANGLES_EX:
                         log::write("Triangles with OMM attachment passed to acceleration structure build when OMM is not supported");
                         return false;
-                    case NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_DMM_TRIANGLES_EX: // GetRaytracingCaps reports no DMM caps, we shouldn't reach this
+                    case NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_DMM_TRIANGLES_EX:
                         log::write("Triangles with DMM attachment passed to acceleration structure build when DMM is not supported");
                         return false;
                     default:
@@ -352,6 +439,16 @@ extern "C" {
         if (pDevice == nullptr || pParams == nullptr)
             return InvalidArgument(n);
 
+        if (auto result = NvapiD3d12Device::GetRaytracingAccelerationStructurePrebuildInfoEx(pDevice, pParams); result.has_value()) {
+            auto value = result.value();
+            if (value == NVAPI_OK) {
+                return Ok(n, alreadyLoggedOk);
+            } else {
+                log::write(str::format(n, ": ", value));
+                return value;
+            }
+        }
+
         if (pParams->version != NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS_VER1)
             return IncompatibleStructVersion(n);
 
@@ -362,13 +459,73 @@ extern "C" {
         D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS desc{};
 
         if (!ConvertBuildRaytracingAccelerationStructureInputs(pParams->pDesc, geometryDescs, &desc))
-            return InvalidArgument(n);
+            return NotSupported(n);
 
         pDevice->GetRaytracingAccelerationStructurePrebuildInfo(&desc, pParams->pInfo);
 
         return Ok(n, alreadyLoggedOk);
     }
 
+    NvAPI_Status __cdecl NvAPI_D3D12_BuildRaytracingOpacityMicromapArray(ID3D12GraphicsCommandList4* pCommandList, NVAPI_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS* pParams) {
+        constexpr auto n = __func__;
+        static bool alreadyLoggedOk = false;
+
+        if (pCommandList == nullptr || pParams == nullptr)
+            return InvalidArgument(n);
+
+        if (auto result = NvapiD3d12Device::BuildRaytracingOpacityMicromapArray(pCommandList, pParams); result.has_value()) {
+            auto value = result.value();
+            if (value == NVAPI_OK) {
+                return Ok(n, alreadyLoggedOk);
+            } else {
+                log::write(str::format(n, ": ", value));
+                return value;
+            }
+        }
+
+        return NotSupported(n);
+    }
+
+    NvAPI_Status __cdecl NvAPI_D3D12_RelocateRaytracingOpacityMicromapArray(ID3D12GraphicsCommandList4* pCommandList, const NVAPI_RELOCATE_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS* pParams) {
+        constexpr auto n = __func__;
+        static bool alreadyLoggedOk = false;
+
+        if (pCommandList == nullptr || pParams == nullptr)
+            return InvalidArgument(n);
+
+        if (auto result = NvapiD3d12Device::RelocateRaytracingOpacityMicromapArray(pCommandList, pParams); result.has_value()) {
+            auto value = result.value();
+            if (value == NVAPI_OK) {
+                return Ok(n, alreadyLoggedOk);
+            } else {
+                log::write(str::format(n, ": ", value));
+                return value;
+            }
+        }
+
+        return NotSupported(n);
+    }
+
+    NvAPI_Status __cdecl NvAPI_D3D12_EmitRaytracingOpacityMicromapArrayPostbuildInfo(ID3D12GraphicsCommandList4* pCommandList, const NVAPI_EMIT_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_PARAMS* pParams) {
+        constexpr auto n = __func__;
+        static bool alreadyLoggedOk = false;
+
+        if (pCommandList == nullptr || pParams == nullptr)
+            return InvalidArgument(n);
+
+        if (auto result = NvapiD3d12Device::EmitRaytracingOpacityMicromapArrayPostbuildInfo(pCommandList, pParams); result.has_value()) {
+            auto value = result.value();
+            if (value == NVAPI_OK) {
+                return Ok(n, alreadyLoggedOk);
+            } else {
+                log::write(str::format(n, ": ", value));
+                return value;
+            }
+        }
+
+        return NotSupported(n);
+    }
+
     NvAPI_Status __cdecl NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(ID3D12GraphicsCommandList4* pCommandList, const NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS* pParams) {
         constexpr auto n = __func__;
         static bool alreadyLoggedOk = false;
@@ -376,6 +533,16 @@ extern "C" {
         if (pCommandList == nullptr || pParams == nullptr)
             return InvalidArgument(n);
 
+        if (auto result = NvapiD3d12Device::BuildRaytracingAccelerationStructureEx(pCommandList, pParams); result.has_value()) {
+            auto value = result.value();
+            if (value == NVAPI_OK) {
+                return Ok(n, alreadyLoggedOk);
+            } else {
+                log::write(str::format(n, ": ", value));
+                return value;
+            }
+        }
+
         if (pParams->version != NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS_VER1)
             return IncompatibleStructVersion(n);
 
@@ -391,7 +558,7 @@ extern "C" {
         };
 
         if (!ConvertBuildRaytracingAccelerationStructureInputs(&pParams->pDesc->inputs, geometryDescs, &desc.Inputs))
-            return InvalidArgument(n);
+            return NotSupported(n);
 
         pCommandList->BuildRaytracingAccelerationStructure(&desc, pParams->numPostbuildInfoDescs, pParams->pPostbuildInfoDescs);
 
diff --git a/src/nvapi_interface.cpp b/src/nvapi_interface.cpp
index b461166..6c8728c 100644
--- a/src/nvapi_interface.cpp
+++ b/src/nvapi_interface.cpp
@@ -67,7 +67,13 @@ extern "C" {
         INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D12_GetGraphicsCapabilities)
         INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D12_IsFatbinPTXSupported)
         INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D12_GetRaytracingCaps)
+        INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D12_GetRaytracingOpacityMicromapArrayPrebuildInfo)
+        INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D12_SetCreatePipelineStateOptions)
+        INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D12_CheckDriverMatchingIdentifierEx)
         INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D12_GetRaytracingAccelerationStructurePrebuildInfoEx)
+        INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D12_BuildRaytracingOpacityMicromapArray)
+        INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D12_RelocateRaytracingOpacityMicromapArray)
+        INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D12_EmitRaytracingOpacityMicromapArrayPostbuildInfo)
         INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx)
         INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D_GetObjectHandleForResource)
         INSERT_AND_RETURN_WHEN_EQUALS(NvAPI_D3D_SetResourceHint)
diff --git a/src/vkd3d-proton/vkd3d-proton_interfaces.cpp b/src/vkd3d-proton/vkd3d-proton_interfaces.cpp
index 03a4acd..bf811d8 100644
--- a/src/vkd3d-proton/vkd3d-proton_interfaces.cpp
+++ b/src/vkd3d-proton/vkd3d-proton_interfaces.cpp
@@ -18,6 +18,8 @@
 #include "vkd3d-proton_interfaces.h"
 
 const GUID ID3D12DeviceExt::guid = {0x11ea7a1a, 0x0f6a, 0x49bf, {0xb6, 0x12, 0x3e, 0x30, 0xf8, 0xe2, 0x01, 0xdd}};
+const GUID ID3D12DeviceExt1::guid = {0x11ea7a1a, 0x0f6a, 0x49bf, {0xb6, 0x12, 0x3e, 0x30, 0xf8, 0xe2, 0x01, 0xde}};
 const GUID ID3D12GraphicsCommandListExt::guid = {0x77a86b09, 0x2bea, 0x4801, {0xb8, 0x9a, 0x37, 0x64, 0x8e, 0x10, 0x4a, 0xf1}};
 const GUID ID3D12GraphicsCommandListExt1::guid = {0xd53b0028, 0xafb4, 0x4b65, {0xa4, 0xf1, 0x7b, 0x0d, 0xaa, 0xa6, 0x5b, 0x4f}};
+const GUID ID3D12GraphicsCommandListExt2::guid = {0xd53b0028, 0xafb4, 0x4b65, {0xa4, 0xf1, 0x7b, 0x0d, 0xaa, 0xa6, 0x5b, 0x50}};
 const GUID ID3D12CommandQueueExt::guid = {0x40ed3f96, 0xe773, 0xe9bc, {0xfc, 0x0c, 0xe9, 0x55, 0x60, 0xc9, 0x9a, 0xd6}};
diff --git a/src/vkd3d-proton/vkd3d-proton_interfaces.h b/src/vkd3d-proton/vkd3d-proton_interfaces.h
index 8f388ac..d03a215 100644
--- a/src/vkd3d-proton/vkd3d-proton_interfaces.h
+++ b/src/vkd3d-proton/vkd3d-proton_interfaces.h
@@ -28,6 +28,7 @@
     inline GUID const& __mingw_uuidof<iface>() { return iface::guid; }
 
 enum D3D12_VK_EXTENSION : uint32_t {
+    D3D12_VK_EXT_OPACITY_MICROMAP = 0x0,
     D3D12_VK_NVX_BINARY_IMPORT = 0x1,
     D3D12_VK_NVX_IMAGE_VIEW_HANDLE = 0x2,
     D3D12_VK_NV_LOW_LATENCY_2 = 0x3
@@ -83,6 +84,22 @@ ID3D12DeviceExt : public IUnknown {
         D3D12_UAV_INFO * uav_info) = 0;
 };
 
+MIDL_INTERFACE("11ea7a1a-0f6a-49bf-b612-3e30f8e201de")
+ID3D12DeviceExt1 : public ID3D12DeviceExt {
+    static const GUID guid;
+    virtual HRESULT STDMETHODCALLTYPE SetCreatePipelineStateOptions(
+        const void* params) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE CheckDriverMatchingIdentifierEx(
+        void* params) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetRaytracingAccelerationStructurePrebuildInfoEx(
+        void* params) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetRaytracingOpacityMicromapArrayPrebuildInfo(
+        void* params) = 0;
+};
+
 MIDL_INTERFACE("77a86b09-2bea-4801-b89a-37648e104af1")
 ID3D12GraphicsCommandListExt : public IUnknown {
     static const GUID guid;
@@ -114,15 +131,34 @@ ID3D12GraphicsCommandListExt1 : public ID3D12GraphicsCommandListExt {
         UINT32 raw_params_count) = 0;
 };
 
+MIDL_INTERFACE("d53b0028-afb4-4b65-a4f1-7b0daaa65b50")
+ID3D12GraphicsCommandListExt2 : public ID3D12GraphicsCommandListExt1 {
+    static const GUID guid;
+
+    virtual HRESULT STDMETHODCALLTYPE BuildRaytracingAccelerationStructureEx(
+        const void* params) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE BuildRaytracingOpacityMicromapArray(
+        void* params) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE RelocateRaytracingOpacityMicromapArray(
+        const void* params) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE EmitRaytracingOpacityMicromapArrayPostbuildInfo(
+        const void* params) = 0;
+};
+
 MIDL_INTERFACE("40ed3f96-e773-e9bc-fc0c-e95560c99ad6")
 ID3D12CommandQueueExt : public IUnknown {
     static const GUID guid;

     virtual HRESULT STDMETHODCALLTYPE NotifyOutOfBandCommandQueue(
         D3D12_OUT_OF_BAND_CQ_TYPE type) = 0;
 };

 VKD3D_PROTON_GUID(ID3D12DeviceExt)
+VKD3D_PROTON_GUID(ID3D12DeviceExt1)
 VKD3D_PROTON_GUID(ID3D12GraphicsCommandListExt)
 VKD3D_PROTON_GUID(ID3D12GraphicsCommandListExt1)
+VKD3D_PROTON_GUID(ID3D12GraphicsCommandListExt2)
 VKD3D_PROTON_GUID(ID3D12CommandQueueExt)
diff --git a/tests/nvapi_d3d12.cpp b/tests/nvapi_d3d12.cpp
index 7e58728..f78b116 100644
--- a/tests/nvapi_d3d12.cpp
+++ b/tests/nvapi_d3d12.cpp
@@ -29,6 +29,10 @@ TEST_CASE("D3D12 methods succeed", "[.d3d12]") {
         .LR_SIDE_EFFECT(*_2 = static_cast<ID3D12DeviceExt*>(&device))
         .LR_SIDE_EFFECT(deviceRefCount++)
         .RETURN(S_OK);
+    ALLOW_CALL(device, QueryInterface(ID3D12DeviceExt1::guid, _))
+        .LR_SIDE_EFFECT(*_2 = static_cast<ID3D12DeviceExt1*>(&device))
+        .LR_SIDE_EFFECT(deviceRefCount++)
+        .RETURN(S_OK);
     ALLOW_CALL(device, AddRef())
         .LR_SIDE_EFFECT(deviceRefCount++)
         .RETURN(deviceRefCount);
@@ -48,7 +52,11 @@ TEST_CASE("D3D12 methods succeed", "[.d3d12]") {
         .LR_SIDE_EFFECT(commandListRefCount++)
         .RETURN(S_OK);
     ALLOW_CALL(commandList, QueryInterface(ID3D12GraphicsCommandListExt1::guid, _))
-        .LR_SIDE_EFFECT(*_2 = static_cast<ID3D12GraphicsCommandListExt*>(&commandList))
+        .LR_SIDE_EFFECT(*_2 = static_cast<ID3D12GraphicsCommandListExt1*>(&commandList))
+        .LR_SIDE_EFFECT(commandListRefCount++)
+        .RETURN(S_OK);
+    ALLOW_CALL(commandList, QueryInterface(ID3D12GraphicsCommandListExt2::guid, _))
+        .LR_SIDE_EFFECT(*_2 = static_cast<ID3D12GraphicsCommandListExt2*>(&commandList))
         .LR_SIDE_EFFECT(commandListRefCount++)
         .RETURN(S_OK);
     ALLOW_CALL(commandList, AddRef())
@@ -75,18 +83,30 @@ TEST_CASE("D3D12 methods succeed", "[.d3d12]") {
     SECTION("D3D12 methods without VKD3D-Proton return error") {
         ALLOW_CALL(device, QueryInterface(ID3D12DeviceExt::guid, _))
             .RETURN(E_NOINTERFACE);
+        ALLOW_CALL(device, QueryInterface(ID3D12DeviceExt1::guid, _))
+            .RETURN(E_NOINTERFACE);
         ALLOW_CALL(commandList, QueryInterface(ID3D12GraphicsCommandListExt::guid, _))
             .RETURN(E_NOINTERFACE);
         ALLOW_CALL(commandList, QueryInterface(ID3D12GraphicsCommandListExt1::guid, _))
             .RETURN(E_NOINTERFACE);
+        ALLOW_CALL(commandList, QueryInterface(ID3D12GraphicsCommandListExt2::guid, _))
+            .RETURN(E_NOINTERFACE);
 
         FORBID_CALL(device, CreateCubinComputeShaderWithName(_, _, _, _, _, _, _));
         FORBID_CALL(device, DestroyCubinComputeShader(_));
         FORBID_CALL(device, GetCudaTextureObject(_, _, _));
         FORBID_CALL(device, GetCudaSurfaceObject(_, _));
         FORBID_CALL(device, CaptureUAVInfo(_));
+        FORBID_CALL(device, SetCreatePipelineStateOptions(_));
+        FORBID_CALL(device, CheckDriverMatchingIdentifierEx(_));
+        FORBID_CALL(device, GetRaytracingAccelerationStructurePrebuildInfoEx(_));
+        FORBID_CALL(device, GetRaytracingOpacityMicromapArrayPrebuildInfo(_));
         FORBID_CALL(commandList, LaunchCubinShader(_, _, _, _, _, _));
         FORBID_CALL(commandList, LaunchCubinShaderEx(_, _, _, _, _, _, _, _, _));
+        FORBID_CALL(commandList, BuildRaytracingAccelerationStructureEx(_));
+        FORBID_CALL(commandList, BuildRaytracingOpacityMicromapArray(_));
+        FORBID_CALL(commandList, RelocateRaytracingOpacityMicromapArray(_));
+        FORBID_CALL(commandList, EmitRaytracingOpacityMicromapArrayPostbuildInfo(_));
 
         REQUIRE(NvAPI_D3D12_CreateCubinComputeShaderWithName(static_cast<ID3D12Device*>(&device), nullptr, 0, 0, 0, 0, "shader_name", nullptr) == NVAPI_ERROR);
         REQUIRE(NvAPI_D3D12_CreateCubinComputeShader(static_cast<ID3D12Device*>(&device), nullptr, 0, 0, 0, 0, nullptr) == NVAPI_ERROR);
@@ -101,11 +121,46 @@ TEST_CASE("D3D12 methods succeed", "[.d3d12]") {
         REQUIRE(NvAPI_D3D12_IsFatbinPTXSupported(static_cast<ID3D12Device*>(&device), &isPTXSupported) == NVAPI_ERROR);
 
         REQUIRE(NvAPI_D3D12_LaunchCubinShader(static_cast<ID3D12GraphicsCommandList*>(&commandList), reinterpret_cast<NVDX_ObjectHandle>(0), 0, 0, 0, nullptr, 0) == NVAPI_ERROR);
+
+        {
+            NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS caps = NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_STANDARD;
+            REQUIRE(NvAPI_D3D12_GetRaytracingCaps(static_cast<ID3D12Device*>(&device), NVAPI_D3D12_RAYTRACING_CAPS_TYPE_OPACITY_MICROMAP, &caps, sizeof(caps)) == NVAPI_OK);
+            REQUIRE(caps == NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_NONE);
+        }
+        {
+            NVAPI_GET_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO_PARAMS params{};
+            REQUIRE(NvAPI_D3D12_GetRaytracingOpacityMicromapArrayPrebuildInfo(static_cast<ID3D12Device5*>(&device), &params) != NVAPI_OK);
+        }
+        {
+            NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS params{};
+            params.version = NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS_VER1;
+            params.flags = NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS_ENABLE_OMM_SUPPORT;
+            REQUIRE(NvAPI_D3D12_SetCreatePipelineStateOptions(static_cast<ID3D12Device5*>(&device), &params) != NVAPI_OK);
+        }
+        {
+            NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS params{};
+            params.version = NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS_VER1;
+            params.serializedDataType = NVAPI_D3D12_SERIALIZED_DATA_RAYTRACING_OPACITY_MICROMAP_ARRAY_EX;
+            REQUIRE(NvAPI_D3D12_CheckDriverMatchingIdentifierEx(static_cast<ID3D12Device5*>(&device), &params) != NVAPI_OK);
+        }
+        {
+            NVAPI_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS params{};
+            REQUIRE(NvAPI_D3D12_BuildRaytracingOpacityMicromapArray(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) != NVAPI_OK);
+        }
+        {
+            NVAPI_RELOCATE_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS params{};
+            REQUIRE(NvAPI_D3D12_RelocateRaytracingOpacityMicromapArray(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) != NVAPI_OK);
+        }
+        {
+            NVAPI_EMIT_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_PARAMS params{};
+            REQUIRE(NvAPI_D3D12_EmitRaytracingOpacityMicromapArrayPostbuildInfo(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) != NVAPI_OK);
+        }
+
         REQUIRE(deviceRefCount == 0);
         REQUIRE(commandListRefCount == 0);
     }
 
-    SECTION("D3D12 methods without cubin extension return error") {
+    SECTION("D3D12 cubin methods without cubin extension return error") {
         ALLOW_CALL(device, GetExtensionSupport(D3D12_VK_NVX_BINARY_IMPORT))
             .RETURN(false);
 
@@ -130,6 +185,36 @@ TEST_CASE("D3D12 methods succeed", "[.d3d12]") {
         REQUIRE(commandListRefCount == 0);
     }
 
+    SECTION("D3D12 OMM methods without OMM extension return not-supported") {
+        ALLOW_CALL(device, GetExtensionSupport(D3D12_VK_EXT_OPACITY_MICROMAP))
+            .RETURN(false);
+
+        FORBID_CALL(device, SetCreatePipelineStateOptions(_));
+        FORBID_CALL(device, CheckDriverMatchingIdentifierEx(_));
+        FORBID_CALL(device, GetRaytracingAccelerationStructurePrebuildInfoEx(_));
+        FORBID_CALL(device, GetRaytracingOpacityMicromapArrayPrebuildInfo(_));
+
+        {
+            NVAPI_GET_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO_PARAMS params{};
+            REQUIRE(NvAPI_D3D12_GetRaytracingOpacityMicromapArrayPrebuildInfo(static_cast<ID3D12Device5*>(&device), &params) != NVAPI_OK);
+        }
+        {
+            NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS params{};
+            params.version = NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS_VER1;
+            params.flags = NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS_ENABLE_OMM_SUPPORT;
+            REQUIRE(NvAPI_D3D12_SetCreatePipelineStateOptions(static_cast<ID3D12Device5*>(&device), &params) != NVAPI_OK);
+        }
+        {
+            NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS params{};
+            params.version = NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS_VER1;
+            params.serializedDataType = NVAPI_D3D12_SERIALIZED_DATA_RAYTRACING_OPACITY_MICROMAP_ARRAY_EX;
+            REQUIRE(NvAPI_D3D12_CheckDriverMatchingIdentifierEx(static_cast<ID3D12Device5*>(&device), &params) != NVAPI_OK);
+        }
+
+        REQUIRE(deviceRefCount == 0);
+        REQUIRE(commandListRefCount == 0);
+    }
+
     SECTION("IsNvShaderExtnOpCodeSupported returns OK") {
         auto supported = true;
         REQUIRE(NvAPI_D3D12_IsNvShaderExtnOpCodeSupported(&device, 1U, &supported) == NVAPI_OK);
@@ -434,6 +519,8 @@ TEST_CASE("D3D12 methods succeed", "[.d3d12]") {
     SECTION("Launch CuBIN without ID3D12GraphicsCommandListExt1 returns OK") {
         ALLOW_CALL(commandList, QueryInterface(ID3D12GraphicsCommandListExt1::guid, _))
             .RETURN(E_NOINTERFACE);
+        ALLOW_CALL(commandList, QueryInterface(ID3D12GraphicsCommandListExt2::guid, _))
+            .RETURN(E_NOINTERFACE);
 
         auto shaderHandle = reinterpret_cast<D3D12_CUBIN_DATA_HANDLE*>(0xbadcf00d);
         auto blockX = 1U;
@@ -457,8 +544,20 @@ TEST_CASE("D3D12 methods succeed", "[.d3d12]") {
         REQUIRE(caps == NVAPI_D3D12_RAYTRACING_THREAD_REORDERING_CAP_NONE);
     }
 
-    SECTION("GetRaytracingCaps returns OK and claims that Opacity Micromap is not supported") {
-        NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS caps;
+    SECTION("GetRaytracingCaps returns OK and claims that Opacity Micromaps are not supported if ID3D12DeviceExt1 interface can't be found") {
+        ALLOW_CALL(device, QueryInterface(ID3D12DeviceExt1::guid, _))
+            .RETURN(E_NOINTERFACE);
+
+        NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS caps = NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_STANDARD;
+        REQUIRE(NvAPI_D3D12_GetRaytracingCaps(static_cast<ID3D12Device*>(&device), NVAPI_D3D12_RAYTRACING_CAPS_TYPE_OPACITY_MICROMAP, &caps, sizeof(caps)) == NVAPI_OK);
+        REQUIRE(caps == NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_NONE);
+    }
+
+    SECTION("GetRaytracingCaps returns OK and claims that Opacity Micromaps are not supported if OMM extension is not supported") {
+        ALLOW_CALL(device, GetExtensionSupport(D3D12_VK_EXT_OPACITY_MICROMAP))
+            .RETURN(false);
+
+        NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS caps = NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_STANDARD;
         REQUIRE(NvAPI_D3D12_GetRaytracingCaps(static_cast<ID3D12Device*>(&device), NVAPI_D3D12_RAYTRACING_CAPS_TYPE_OPACITY_MICROMAP, &caps, sizeof(caps)) == NVAPI_OK);
         REQUIRE(caps == NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_NONE);
     }
@@ -469,7 +568,10 @@ TEST_CASE("D3D12 methods succeed", "[.d3d12]") {
         REQUIRE(caps == NVAPI_D3D12_RAYTRACING_DISPLACEMENT_MICROMAP_CAP_NONE);
     }
 
-    SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx succeeds") {
+    SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx succeeds when Opacity Micromaps are not supported") {
+        ALLOW_CALL(device, GetExtensionSupport(D3D12_VK_EXT_OPACITY_MICROMAP))
+            .RETURN(false);
+
         SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx returns OK") {
             NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_EX desc{};
             D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO info{};
@@ -601,7 +703,181 @@ TEST_CASE("D3D12 methods succeed", "[.d3d12]") {
         }
     }
 
-    SECTION("BuildRaytracingAccelerationStructureEx succeeds") {
+    SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx fails when Opacity Micromaps are used but they are not supported") {
+        ALLOW_CALL(device, GetExtensionSupport(D3D12_VK_EXT_OPACITY_MICROMAP))
+            .RETURN(false);
+
+        FORBID_CALL(device, GetRaytracingAccelerationStructurePrebuildInfo(_, _));
+        FORBID_CALL(device, GetRaytracingAccelerationStructurePrebuildInfoEx(_));
+
+        NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX geometryDescEx{};
+        NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_EX desc{};
+        D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO info{};
+        NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS params{};
+        params.version = NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS_VER1;
+        params.pDesc = &desc;
+        params.pInfo = &info;
+
+        SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx with allow OMM update flag") {
+            desc.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;
+            desc.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_OMM_UPDATE_EX;
+
+            REQUIRE(NvAPI_D3D12_GetRaytracingAccelerationStructurePrebuildInfoEx(static_cast<ID3D12Device5*>(&device), &params) != NVAPI_OK);
+        }
+
+        SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx with allow disable OMMs flag") {
+            desc.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;
+            desc.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_DISABLE_OMMS_EX;
+
+            REQUIRE(NvAPI_D3D12_GetRaytracingAccelerationStructurePrebuildInfoEx(static_cast<ID3D12Device5*>(&device), &params) != NVAPI_OK);
+        }
+
+        SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx with allow OMM opacity states update flag") {
+            desc.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;
+            desc.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_OMM_OPACITY_STATES_UPDATE_EX;
+
+            REQUIRE(NvAPI_D3D12_GetRaytracingAccelerationStructurePrebuildInfoEx(static_cast<ID3D12Device5*>(&device), &params) != NVAPI_OK);
+        }
+
+        SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx with BLAS for array and OMM triangles") {
+            desc.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;
+            desc.descsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY;
+            desc.numDescs = 1;
+            desc.pGeometryDescs = &geometryDescEx;
+            desc.geometryDescStrideInBytes = sizeof(geometryDescEx);
+            geometryDescEx.type = NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_OMM_TRIANGLES_EX;
+
+            REQUIRE(NvAPI_D3D12_GetRaytracingAccelerationStructurePrebuildInfoEx(static_cast<ID3D12Device5*>(&device), &params) != NVAPI_OK);
+        }
+
+        SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx with BLAS for pointer array and OMM triangles") {
+            NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX* geometryDescExArray[] = {&geometryDescEx};
+            desc.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;
+            desc.descsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY_OF_POINTERS;
+            desc.numDescs = 1;
+            desc.ppGeometryDescs = geometryDescExArray;
+            desc.geometryDescStrideInBytes = sizeof(geometryDescEx);
+            geometryDescEx.type = NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_OMM_TRIANGLES_EX;
+
+            REQUIRE(NvAPI_D3D12_GetRaytracingAccelerationStructurePrebuildInfoEx(static_cast<ID3D12Device5*>(&device), &params) != NVAPI_OK);
+        }
+    }
+
+    SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx succeeds when Opacity Micromaps are supported") {
+        SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx returns OK and calls to ID3D12DeviceExt1") {
+            NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX geometryDescEx{};
+            NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_EX desc{};
+            D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO info{};
+            NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS params{};
+            params.version = NVAPI_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_EX_PARAMS_VER1;
+            params.pDesc = &desc;
+            params.pInfo = &info;
+
+            REQUIRE_CALL(device, GetRaytracingAccelerationStructurePrebuildInfoEx(&params))
+                .RETURN(NVAPI_OK)
+                .TIMES(1);
+
+            SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx with TLAS") {
+                desc.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;
+                desc.instanceDescs = D3D12_GPU_VIRTUAL_ADDRESS{};
+                desc.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_OMM_UPDATE_EX;
+
+                REQUIRE(NvAPI_D3D12_GetRaytracingAccelerationStructurePrebuildInfoEx(static_cast<ID3D12Device5*>(&device), &params) == NVAPI_OK);
+            }
+
+            SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx with BLAS for pointer array") {
+                NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX* geometryDescExArray[] = {};
+                desc.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;
+                desc.descsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY_OF_POINTERS;
+                desc.ppGeometryDescs = geometryDescExArray;
+                desc.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_DISABLE_OMMS_EX;
+
+                REQUIRE(NvAPI_D3D12_GetRaytracingAccelerationStructurePrebuildInfoEx(static_cast<ID3D12Device5*>(&device), &params) == NVAPI_OK);
+            }
+
+            SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx with BLAS for array") {
+                desc.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;
+                desc.descsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY;
+                desc.numDescs = 1;
+                desc.pGeometryDescs = &geometryDescEx;
+                desc.geometryDescStrideInBytes = sizeof(geometryDescEx);
+                desc.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_OMM_OPACITY_STATES_UPDATE_EX;
+
+                SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx for OMM triangles geometry") {
+                    geometryDescEx.type = NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_OMM_TRIANGLES_EX;
+                    geometryDescEx.ommTriangles.triangles.IndexBuffer = D3D12_GPU_VIRTUAL_ADDRESS{};
+                    geometryDescEx.ommTriangles.ommAttachment.opacityMicromapArray = D3D12_GPU_VIRTUAL_ADDRESS{};
+
+                    REQUIRE(NvAPI_D3D12_GetRaytracingAccelerationStructurePrebuildInfoEx(static_cast<ID3D12Device5*>(&device), &params) == NVAPI_OK);
+                }
+
+                SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx for triangles geometry") {
+                    geometryDescEx.type = NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES_EX;
+                    geometryDescEx.triangles.IndexBuffer = D3D12_GPU_VIRTUAL_ADDRESS{};
+
+                    REQUIRE(NvAPI_D3D12_GetRaytracingAccelerationStructurePrebuildInfoEx(static_cast<ID3D12Device5*>(&device), &params) == NVAPI_OK);
+                }
+
+                SECTION("GetRaytracingAccelerationStructurePrebuildInfoEx with AABBs geometry") {
+                    geometryDescEx.type = NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_PROCEDURAL_PRIMITIVE_AABBS_EX;
+                    geometryDescEx.aabbs.AABBCount = 3;
+
+                    REQUIRE(NvAPI_D3D12_GetRaytracingAccelerationStructurePrebuildInfoEx(static_cast<ID3D12Device5*>(&device), &params) == NVAPI_OK);
+                }
+            }
+        }
+    }
+
+    SECTION("GetRaytracingOpacityMicromapArrayPrebuildInfo returns OK") {
+        NVAPI_GET_RAYTRACING_OPACITY_MICROMAP_ARRAY_PREBUILD_INFO_PARAMS params{};
+
+        REQUIRE_CALL(device, GetRaytracingOpacityMicromapArrayPrebuildInfo(&params))
+            .RETURN(NVAPI_OK)
+            .TIMES(1);
+
+        REQUIRE(NvAPI_D3D12_GetRaytracingOpacityMicromapArrayPrebuildInfo(static_cast<ID3D12Device5*>(&device), &params) == NVAPI_OK);
+        REQUIRE(deviceRefCount == 0);
+        REQUIRE(commandListRefCount == 0);
+    }
+
+    SECTION("SetCreatePipelineStateOptions returns OK") {
+        NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS params{};
+        params.version = NVAPI_D3D12_SET_CREATE_PIPELINE_STATE_OPTIONS_PARAMS_VER1;
+        params.flags = NVAPI_D3D12_PIPELINE_CREATION_STATE_FLAGS_ENABLE_OMM_SUPPORT;
+
+        REQUIRE_CALL(device, SetCreatePipelineStateOptions(&params))
+            .RETURN(NVAPI_OK)
+            .TIMES(1);
+
+        REQUIRE(NvAPI_D3D12_SetCreatePipelineStateOptions(static_cast<ID3D12Device5*>(&device), &params) == NVAPI_OK);
+        REQUIRE(deviceRefCount == 0);
+        REQUIRE(commandListRefCount == 0);
+    }
+
+    SECTION("CheckDriverMatchingIdentifierEx returns OK") {
+        NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS params{};
+        params.version = NVAPI_CHECK_DRIVER_MATCHING_IDENTIFIER_EX_PARAMS_VER1;
+        params.serializedDataType = NVAPI_D3D12_SERIALIZED_DATA_RAYTRACING_OPACITY_MICROMAP_ARRAY_EX;
+
+        REQUIRE_CALL(device, CheckDriverMatchingIdentifierEx(&params))
+            .RETURN(NVAPI_OK)
+            .TIMES(1);
+
+        REQUIRE(NvAPI_D3D12_CheckDriverMatchingIdentifierEx(static_cast<ID3D12Device5*>(&device), &params) == NVAPI_OK);
+        REQUIRE(deviceRefCount == 0);
+        REQUIRE(commandListRefCount == 0);
+    }
+
+    SECTION("GetRaytracingCaps returns OK and claims that Opacity Micromaps are supported") {
+        NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAPS caps = NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_NONE;
+        REQUIRE(NvAPI_D3D12_GetRaytracingCaps(static_cast<ID3D12Device*>(&device), NVAPI_D3D12_RAYTRACING_CAPS_TYPE_OPACITY_MICROMAP, &caps, sizeof(caps)) == NVAPI_OK);
+        REQUIRE(caps == NVAPI_D3D12_RAYTRACING_OPACITY_MICROMAP_CAP_STANDARD);
+    }
+
+    SECTION("BuildRaytracingAccelerationStructureEx succeeds when ID3D12GraphicsCommandListExt2 interface can't be found") {
+        ALLOW_CALL(commandList, QueryInterface(ID3D12GraphicsCommandListExt2::guid, _))
+            .RETURN(E_NOINTERFACE);
+
         SECTION("BuildRaytracingAccelerationStructureEx returns OK") {
             NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC_EX desc{};
             NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS params{};
@@ -748,4 +1024,161 @@ TEST_CASE("D3D12 methods succeed", "[.d3d12]") {
             REQUIRE(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) != NVAPI_INCOMPATIBLE_STRUCT_VERSION);
         }
     }
+
+    SECTION("BuildRaytracingAccelerationStructureEx fails when Opacity Micromaps are used but ID3D12GraphicsCommandListExt2 interface can't be found") {
+        ALLOW_CALL(commandList, QueryInterface(ID3D12GraphicsCommandListExt2::guid, _))
+            .RETURN(E_NOINTERFACE);
+
+        FORBID_CALL(commandList, BuildRaytracingAccelerationStructure(_, _, _));
+        FORBID_CALL(commandList, BuildRaytracingAccelerationStructureEx(_));
+
+        NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX geometryDescEx{};
+        NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC_EX desc{};
+        NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS params{};
+        params.version = NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS_VER1;
+        params.pDesc = &desc;
+
+        SECTION("BuildRaytracingAccelerationStructureEx with allow OMM update flag") {
+            desc.inputs.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;
+            desc.inputs.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_OMM_UPDATE_EX;
+
+            REQUIRE(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) != NVAPI_OK);
+        }
+
+        SECTION("BuildRaytracingAccelerationStructureEx with allow disable OMMs flag") {
+            desc.inputs.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;
+            desc.inputs.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_DISABLE_OMMS_EX;
+
+            REQUIRE(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) != NVAPI_OK);
+        }
+
+        SECTION("BuildRaytracingAccelerationStructureEx with allow OMM opacity states update flag") {
+            desc.inputs.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;
+            desc.inputs.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_OMM_OPACITY_STATES_UPDATE_EX;
+
+            REQUIRE(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) != NVAPI_OK);
+        }
+
+        SECTION("BuildRaytracingAccelerationStructureEx with BLAS for array and OMM triangles") {
+            desc.inputs.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;
+            desc.inputs.descsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY;
+            desc.inputs.numDescs = 1;
+            desc.inputs.pGeometryDescs = &geometryDescEx;
+            desc.inputs.geometryDescStrideInBytes = sizeof(geometryDescEx);
+            geometryDescEx.type = NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_OMM_TRIANGLES_EX;
+
+            REQUIRE(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) != NVAPI_OK);
+        }
+
+        SECTION("BuildRaytracingAccelerationStructureEx with BLAS for pointer array and OMM triangles") {
+            NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX* geometryDescExArray[] = {&geometryDescEx};
+            desc.inputs.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;
+            desc.inputs.descsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY_OF_POINTERS;
+            desc.inputs.numDescs = 1;
+            desc.inputs.ppGeometryDescs = geometryDescExArray;
+            desc.inputs.geometryDescStrideInBytes = sizeof(geometryDescEx);
+            geometryDescEx.type = NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_OMM_TRIANGLES_EX;
+
+            REQUIRE(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) != NVAPI_OK);
+        }
+    }
+
+    SECTION("BuildRaytracingAccelerationStructureEx succeeds when ID3D12GraphicsCommandListExt2 interface can be found") {
+        SECTION("BuildRaytracingAccelerationStructureEx returns OK and calls to ID3D12DeviceExt1") {
+            NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX geometryDescEx{};
+            NVAPI_D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC_EX desc{};
+            NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS params{};
+            params.version = NVAPI_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_EX_PARAMS_VER1;
+            params.pDesc = &desc;
+
+            REQUIRE_CALL(commandList, BuildRaytracingAccelerationStructureEx(&params))
+                .RETURN(NVAPI_OK)
+                .TIMES(1);
+
+            SECTION("BuildRaytracingAccelerationStructureEx with TLAS") {
+                desc.inputs.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;
+                desc.inputs.instanceDescs = D3D12_GPU_VIRTUAL_ADDRESS{};
+                desc.inputs.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_OMM_UPDATE_EX;
+
+                REQUIRE(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) == NVAPI_OK);
+            }
+
+            SECTION("BuildRaytracingAccelerationStructureEx with BLAS for pointer array") {
+                NVAPI_D3D12_RAYTRACING_GEOMETRY_DESC_EX* geometryDescExArray[] = {};
+                desc.inputs.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;
+                desc.inputs.descsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY_OF_POINTERS;
+                desc.inputs.ppGeometryDescs = geometryDescExArray;
+                desc.inputs.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_DISABLE_OMMS_EX;
+
+                REQUIRE(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) == NVAPI_OK);
+            }
+
+            SECTION("BuildRaytracingAccelerationStructureEx with BLAS for array") {
+                desc.inputs.type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;
+                desc.inputs.descsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY;
+                desc.inputs.numDescs = 1;
+                desc.inputs.pGeometryDescs = &geometryDescEx;
+                desc.inputs.geometryDescStrideInBytes = sizeof(geometryDescEx);
+                desc.inputs.flags = NVAPI_D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_OMM_OPACITY_STATES_UPDATE_EX;
+
+                SECTION("BuildRaytracingAccelerationStructureEx for OMM triangles geometry") {
+                    geometryDescEx.type = NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_OMM_TRIANGLES_EX;
+                    geometryDescEx.ommTriangles.triangles.IndexBuffer = D3D12_GPU_VIRTUAL_ADDRESS{};
+                    geometryDescEx.ommTriangles.ommAttachment.opacityMicromapArray = D3D12_GPU_VIRTUAL_ADDRESS{};
+
+                    REQUIRE(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) == NVAPI_OK);
+                }
+
+                SECTION("BuildRaytracingAccelerationStructureEx for triangles geometry") {
+                    geometryDescEx.type = NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES_EX;
+                    geometryDescEx.triangles.IndexBuffer = D3D12_GPU_VIRTUAL_ADDRESS{};
+
+                    REQUIRE(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) == NVAPI_OK);
+                }
+
+                SECTION("BuildRaytracingAccelerationStructureEx for AABBs geometry") {
+                    geometryDescEx.type = NVAPI_D3D12_RAYTRACING_GEOMETRY_TYPE_PROCEDURAL_PRIMITIVE_AABBS_EX;
+                    geometryDescEx.aabbs.AABBCount = 3;
+
+                    REQUIRE(NvAPI_D3D12_BuildRaytracingAccelerationStructureEx(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) == NVAPI_OK);
+                }
+            }
+        }
+    }
+
+    SECTION("BuildRaytracingOpacityMicromapArray returns OK") {
+        NVAPI_BUILD_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS params{};
+
+        REQUIRE_CALL(commandList, BuildRaytracingOpacityMicromapArray(&params))
+            .RETURN(NVAPI_OK)
+            .TIMES(1);
+
+        REQUIRE(NvAPI_D3D12_BuildRaytracingOpacityMicromapArray(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) == NVAPI_OK);
+        REQUIRE(deviceRefCount == 0);
+        REQUIRE(commandListRefCount == 0);
+    }
+
+    SECTION("RelocateRaytracingOpacityMicromapArray returns OK") {
+        NVAPI_RELOCATE_RAYTRACING_OPACITY_MICROMAP_ARRAY_PARAMS params{};
+
+        REQUIRE_CALL(commandList, RelocateRaytracingOpacityMicromapArray(&params))
+            .RETURN(NVAPI_OK)
+            .TIMES(1);
+
+        REQUIRE(NvAPI_D3D12_RelocateRaytracingOpacityMicromapArray(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) == NVAPI_OK);
+        REQUIRE(deviceRefCount == 0);
+        REQUIRE(commandListRefCount == 0);
+    }
+
+    SECTION("EmitRaytracingOpacityMicromapArrayPostbuildInfo returns OK") {
+        NVAPI_EMIT_RAYTRACING_OPACITY_MICROMAP_ARRAY_POSTBUILD_INFO_PARAMS params{};
+
+        REQUIRE_CALL(commandList, EmitRaytracingOpacityMicromapArrayPostbuildInfo(&params))
+            .RETURN(NVAPI_OK)
+            .TIMES(1);
+
+        REQUIRE(NvAPI_D3D12_EmitRaytracingOpacityMicromapArrayPostbuildInfo(static_cast<ID3D12GraphicsCommandList4*>(&commandList), &params) == NVAPI_OK);
+        REQUIRE(deviceRefCount == 0);
+        REQUIRE(commandListRefCount == 0);
+    }
 }
diff --git a/tests/nvapi_d3d12_mocks.h b/tests/nvapi_d3d12_mocks.h
index a3cff71..6a357f2 100644
--- a/tests/nvapi_d3d12_mocks.h
+++ b/tests/nvapi_d3d12_mocks.h
@@ -3,7 +3,7 @@
 #include "nvapi_tests_private.h"
 #include "../src/vkd3d-proton/vkd3d-proton_interfaces.h"
 
-class ID3D12Vkd3dDevice : public ID3D12Device5, public ID3D12DeviceExt {};
+class ID3D12Vkd3dDevice : public ID3D12Device5, public ID3D12DeviceExt1 {};
 
 class D3D12Vkd3dDeviceMock final : public trompeloeil::mock_interface<ID3D12Vkd3dDevice> {
     MAKE_MOCK2(QueryInterface, HRESULT(REFIID, void**), override);
@@ -78,9 +78,13 @@ class D3D12Vkd3dDeviceMock final : public trompeloeil::mock_interface<ID3D12Vkd3
     IMPLEMENT_MOCK3(GetCudaTextureObject);
     IMPLEMENT_MOCK2(GetCudaSurfaceObject);
     IMPLEMENT_MOCK1(CaptureUAVInfo);
+    IMPLEMENT_MOCK1(SetCreatePipelineStateOptions);
+    IMPLEMENT_MOCK1(CheckDriverMatchingIdentifierEx);
+    IMPLEMENT_MOCK1(GetRaytracingAccelerationStructurePrebuildInfoEx);
+    IMPLEMENT_MOCK1(GetRaytracingOpacityMicromapArrayPrebuildInfo);
 };
 
-class ID3D12Vkd3dGraphicsCommandList : public ID3D12GraphicsCommandList4, public ID3D12GraphicsCommandListExt1 {};
+class ID3D12Vkd3dGraphicsCommandList : public ID3D12GraphicsCommandList4, public ID3D12GraphicsCommandListExt2 {};
 
 class D3D12Vkd3dGraphicsCommandListMock final : public trompeloeil::mock_interface<ID3D12Vkd3dGraphicsCommandList> {
     MAKE_MOCK2(QueryInterface, HRESULT(REFIID, void**), override);
@@ -163,4 +167,8 @@ class D3D12Vkd3dGraphicsCommandListMock final : public trompeloeil::mock_interfa
     IMPLEMENT_MOCK1(GetVulkanHandle);
     IMPLEMENT_MOCK6(LaunchCubinShader);
     IMPLEMENT_MOCK9(LaunchCubinShaderEx);
+    IMPLEMENT_MOCK1(BuildRaytracingAccelerationStructureEx);
+    IMPLEMENT_MOCK1(BuildRaytracingOpacityMicromapArray);
+    IMPLEMENT_MOCK1(RelocateRaytracingOpacityMicromapArray);
+    IMPLEMENT_MOCK1(EmitRaytracingOpacityMicromapArrayPostbuildInfo);
 };
